[["r-intermediário.html", "2 R Intermediário", " 2 R Intermediário Para aprofundar nossos conhecimentos sobre a linguagem vamos analisar: Funções da família apply(); O pacote dplyr; O pacote data.table. O pacote gráfico lattice "],["funções-da-família-apply-no-r.html", "2.1 Funções da família apply() no R", " 2.1 Funções da família apply() no R As funções da família apply() são usadas para realizar operações repetitivas em vetores, listas, matrizes e data frames de forma eficiente e vetorizada, substituindo muitos loops explícitos (for). 2.1.1 1. apply() Aplica uma função ao longo de uma margem de uma matriz ou array (linhas ou colunas). Uso: Para matrizes e arrays. Sintaxe: apply(X, MARGIN, FUN, ...) X: Matriz ou array. MARGIN: Margem a operar: 1 para linhas. 2 para colunas. FUN: Função a ser aplicada. Exemplo: # Soma das colunas de uma matriz mat &lt;- matrix(1:9, nrow = 3) apply(mat, 2, sum) # Resultado: [1] 12 15 18 # Média das linhas apply(mat, 1, mean) # Resultado: [1] 2 5 8 2.1.2 2. lapply() Aplica uma função a cada elemento de uma lista ou vetor e retorna uma lista como resultado. Uso: Para listas e vetores. Sintaxe: lapply(X, FUN, ...) Exemplo: # Quadrado de cada elemento de um vetor vec &lt;- 1:5 lapply(vec, function(x) x^2) # Resultado: [[1]] 1, [[2]] 4, [[3]] 9, [[4]] 16, [[5]] 25 # Aplicação em uma lista lst &lt;- list(a = 1:3, b = 4:6) lapply(lst, sum) # Resultado: $a 6, $b 15 2.1.3 3. sapply() Uma versão simplificada de lapply() que retorna um vetor ou matriz (se possível) em vez de uma lista. Uso: Para listas e vetores. Sintaxe: sapply(X, FUN, ...) Exemplo: # Quadrado de cada elemento vec &lt;- 1:5 sapply(vec, function(x) x^2) # Resultado: [1] 1 4 9 16 25 # Soma dos elementos em uma lista lst &lt;- list(a = 1:3, b = 4:6) sapply(lst, sum) # Resultado: [1] 6 15 2.1.4 4. vapply() Semelhante a sapply(), mas requer que você especifique o tipo de retorno esperado (mais seguro). Uso: Para listas e vetores. Sintaxe: vapply(X, FUN, FUN.VALUE, ...) FUN.VALUE: Define o tipo e formato esperado do retorno. Exemplo: # Soma dos elementos em uma lista com tipo esperado (numeric) lst &lt;- list(a = 1:3, b = 4:6) vapply(lst, sum, numeric(1)) # Resultado: [1] 6 15 2.1.5 5. mapply() Aplica uma função a múltiplos argumentos/vetores simultaneamente (como um map em Python). Uso: Para múltiplos vetores ou listas. Sintaxe: mapply(FUN, ..., MoreArgs = NULL) Exemplo: # Soma de dois vetores vec1 &lt;- 1:5 vec2 &lt;- 6:10 mapply(sum, vec1, vec2) # Resultado: [1] 7 9 11 13 15 # Repetição customizada mapply(rep, 1:3, 3:1) # Resultado: [[1]] 1, [[2]] 2 2, [[3]] 3 3 3 2.1.6 6. tapply() Aplica uma função a subconjuntos de um vetor, definidos por um fator ou grupos. Uso: Para agrupamento. Sintaxe: tapply(X, INDEX, FUN, ...) X: Vetor numérico. INDEX: Fator ou lista de fatores para agrupar. Exemplo: # Média por grupo vec &lt;- c(1, 2, 3, 4, 5, 6) grp &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;)) tapply(vec, grp, mean) # Resultado: $A 1.5, $B 3.5, $C 5.5 2.1.7 7. by() Semelhante a tapply(), mas retorna resultados organizados por subgrupos e funciona com data frames. Uso: Para data frames. Sintaxe: by(data, INDICES, FUN, ...) Exemplo: # Soma dos valores por grupo em um data frame df &lt;- data.frame(value = 1:6, group = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;)) by(df$value, df$group, sum) # Resultado: # A: 3 # B: 7 # C: 11 Conclusão As funções da família apply() tornam o R extremamente poderoso e eficiente para manipulação de dados. Use: - apply() para matrizes/arrays. - lapply() e sapply() para listas/vetores. - mapply() para múltiplos vetores. - tapply() e by() para agrupamentos. "],["dplyr.html", "2.2 dplyr", " 2.2 dplyr O pacote dplyr é uma das ferramentas mais populares do ecossistema R para manipulação de dados. Ele fornece uma sintaxe simples e eficiente para tarefas como filtragem, ordenação, agrupamento e transformação de dados. Neste capítulo, exploraremos as principais funções do dplyr aplicadas a um conjunto de dados florestais. 2.2.1 O que é o Pipe %&gt;%? O operador %&gt;% é chamado de pipe. Ele permite encadear funções de maneira a facilitar a leitura e compreensão do código. Ao invés de ficar atribuindo valores intermediários ou aninhando várias funções, você simplesmente passa o resultado de uma função como entrada para a próxima. 2.2.1.1 Exemplos de Uso Vamos usar o conjunto de dados mtcars para entender como o pipe facilita a manipulação de dados: Sem %&gt;% (Sem Pipe) Imagine que queremos fazer as seguintes operações no dataset mtcars: Filtrar apenas os carros que têm mais de 20 milhas por galão (mpg &gt; 20). Selecionar apenas as colunas mpg, cyl, e hp. Sem o operador %&gt;%, o código ficaria assim: library(dplyr) # Sem pipe filtered_data &lt;- filter(mtcars, mpg &gt; 20) selected_data &lt;- select(filtered_data, mpg, cyl, hp) Com %&gt;% (Com Pipe) Podemos simplificar isso usando o pipe: library(dplyr) # Usando pipe selected_data &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) mpg cyl hp Mazda RX4 21.0 6 110 Mazda RX4 Wag 21.0 6 110 Datsun 710 22.8 4 93 Hornet 4 Drive 21.4 6 110 Merc 240D 24.4 4 62 Merc 230 22.8 4 95 Note como o código com %&gt;% é mais legível e direto. Ele segue uma lógica sequencial que permite facilmente entender o que está sendo feito em cada etapa. 2.2.2 Tibbles Tibbles são data frames com ajustes que os deixam mais amigáveis aos cientistas de dados. Elas são parte do pacote {tibble}. Assim, para começar a usá-las, instale e carregue o pacote. install.packages(&quot;tibble&quot;) library(tibble) Criando um exemplo: # Criando um exemplo de dados florestais library(dplyr) dados_florestais &lt;- tibble::tibble( parcela = rep(1:5, each = 10), especie = sample(c(&quot;Cedro&quot;, &quot;Ipê&quot;, &quot;Jatobá&quot;, &quot;Angelim&quot;, &quot;Castanheira&quot;), 50, replace = TRUE), dap_cm = round(runif(50, 10, 80), 1), # Diâmetro em cm altura_m = round(runif(50, 5, 30), 1), # Altura em metros volume_m3 = dap_cm * altura_m * 0.00007854 # Fórmula fictícia para volume ) dados_florestais ## # A tibble: 50 × 5 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Jatobá 41.1 22 0.0710 ## 2 1 Cedro 53.9 27.6 0.117 ## 3 1 Castanheira 10 5.6 0.00440 ## 4 1 Cedro 25.2 29.7 0.0588 ## 5 1 Angelim 59.3 12.6 0.0587 ## 6 1 Ipê 25.1 28.5 0.0562 ## 7 1 Ipê 67 22.2 0.117 ## 8 1 Angelim 31.5 16.2 0.0401 ## 9 1 Cedro 58.1 25.4 0.116 ## 10 1 Angelim 75.3 6 0.0355 ## # ℹ 40 more rows 2.2.3 filter() Podemos filtrar árvores de uma espécie específica ou com características particulares. Exemplo: selecionar árvores com DAP maior que 50 cm. # Filtrando árvores com DAP &gt; 50 cm arvores_grandes &lt;- dados_florestais %&gt;% filter(dap_cm &gt; 50) head(arvores_grandes) ## # A tibble: 6 × 5 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Cedro 53.9 27.6 0.117 ## 2 1 Angelim 59.3 12.6 0.0587 ## 3 1 Ipê 67 22.2 0.117 ## 4 1 Cedro 58.1 25.4 0.116 ## 5 1 Angelim 75.3 6 0.0355 ## 6 2 Jatobá 57.5 25.7 0.116 2.2.4 select() Para trabalhar com um subconjunto de variáveis, podemos usar select(). Exemplo: selecionar apenas as colunas especie, dap_cm e altura_m. # Selecionando colunas específicas dados_selecionados &lt;- dados_florestais %&gt;% select(especie, dap_cm, altura_m) head(dados_selecionados) ## # A tibble: 6 × 3 ## especie dap_cm altura_m ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Jatobá 41.1 22 ## 2 Cedro 53.9 27.6 ## 3 Castanheira 10 5.6 ## 4 Cedro 25.2 29.7 ## 5 Angelim 59.3 12.6 ## 6 Ipê 25.1 28.5 2.2.5 mutate() Podemos criar novas variáveis com base em cálculos. Exemplo: calcular o índice de esbeltez (altura/DAP). # Adicionando o índice de esbeltez dados_florestais &lt;- dados_florestais %&gt;% mutate(indice_esbeltez = altura_m / dap_cm) head(dados_florestais) ## # A tibble: 6 × 6 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Jatobá 41.1 22 0.0710 ## 2 1 Cedro 53.9 27.6 0.117 ## 3 1 Castanheira 10 5.6 0.00440 ## 4 1 Cedro 25.2 29.7 0.0588 ## 5 1 Angelim 59.3 12.6 0.0587 ## 6 1 Ipê 25.1 28.5 0.0562 ## # ℹ 1 more variable: indice_esbeltez &lt;dbl&gt; 2.2.6 arrange() Para ordenar as árvores pelo DAP em ordem decrescente: # Ordenando por DAP dados_ordenados &lt;- dados_florestais %&gt;% arrange(desc(dap_cm)) head(dados_ordenados) ## # A tibble: 6 × 6 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 Castanheira 79.5 29.1 0.182 ## 2 2 Jatobá 78 25 0.153 ## 3 4 Ipê 76.2 17.7 0.106 ## 4 1 Angelim 75.3 6 0.0355 ## 5 4 Castanheira 70.2 24.2 0.133 ## 6 2 Castanheira 68.4 11.9 0.0639 ## # ℹ 1 more variable: indice_esbeltez &lt;dbl&gt; 2.2.7 summarise() e group_by() Agrupar e resumir dados é uma tarefa comum em análises florestais. Exemplo: calcular o DAP médio e o volume total por espécie. # Resumo por espécie resumo_especies &lt;- dados_florestais %&gt;% group_by(especie) %&gt;% summarise( dap_medio = mean(dap_cm), volume_total = sum(volume_m3) ) resumo_especies ## # A tibble: 5 × 3 ## especie dap_medio volume_total ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Angelim 40.7 0.352 ## 2 Castanheira 42.4 0.509 ## 3 Cedro 38.3 0.687 ## 4 Ipê 42.8 0.863 ## 5 Jatobá 43.4 0.785 2.2.8 ungroup() Após usar group_by() em uma análise, o objeto resultante permanece “agrupado”. Isso pode afetar operações subsequentes. Para remover o agrupamento, usamos ungroup(). Exemplo: calcular o DAP médio por espécie e, em seguida, adicionar uma coluna ao dataset original com o DAP médio total (sem agrupamento). # Resumo por espécie com agrupamento resumo_especies &lt;- dados_florestais %&gt;% group_by(especie) %&gt;% summarise(dap_medio = mean(dap_cm)) # Adicionando o DAP médio geral dap_geral &lt;- resumo_especies %&gt;% ungroup() %&gt;% summarise(dap_medio_geral = mean(dap_medio)) dap_geral ## # A tibble: 1 × 1 ## dap_medio_geral ## &lt;dbl&gt; ## 1 41.5 "],["data.html", "2.3 data.table", " 2.3 data.table O pacote data.table é uma extensão do data.frame que combina alta eficiência com uma sintaxe poderosa para manipulação de dados. Ele é especialmente projetado para trabalhar com grandes conjuntos de dados, proporcionando melhor desempenho e flexibilidade em comparação com estruturas tradicionais como o próprio data.frame. 2.3.1 O que é o :=? O operador := é chamado de operador de atribuição por referência. Ele pertence ao pacote data.table e é usado para adicionar ou modificar colunas em um data.table. O := é mais eficiente do que usar &lt;- em um data.table, pois faz as modificações “por referência”, o que significa que não cria cópias desnecessárias dos dados, sendo muito mais rápido e eficiente em termos de memória. 2.3.2 Exemplos de Uso Vamos usar o pacote data.table para entender como o := funciona. Primeiro, vamos criar um data.table com alguns dados fictícios: library(data.table) # Criação de um data.table DT &lt;- data.table( id = 1:5, valor = c(10, 15, 20, 25, 30) ) Adicionando uma Nova Coluna com := Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor: DT[, valor_2 := valor * 2] print(DT) ## id valor valor_2 ## 1: 1 10 20 ## 2: 2 15 30 ## 3: 3 20 40 ## 4: 4 25 50 ## 5: 5 30 60 Adicionando Duas Novas Colunas com := Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor: DT[, valor_3 := valor * 3][, valor_4 := valor * 4] print(DT) ## id valor valor_2 valor_3 valor_4 ## 1: 1 10 20 30 40 ## 2: 2 15 30 45 60 ## 3: 3 20 40 60 80 ## 4: 4 25 50 75 100 ## 5: 5 30 60 90 120 Modificando uma Coluna Existente com := Podemos também modificar uma coluna existente. Vamos modificar a coluna valor_2 para ser o triplo do valor da coluna valor: DT[, valor_2 := valor * 3] print(DT) ## id valor valor_2 valor_3 valor_4 ## 1: 1 10 30 30 40 ## 2: 2 15 45 45 60 ## 3: 3 20 60 60 80 ## 4: 4 25 75 75 100 ## 5: 5 30 90 90 120 "],["pacote-lattice.html", "2.4 Pacote lattice", " 2.4 Pacote lattice O pacote lattice é uma poderosa ferramenta para criar gráficos condicionais e exploratórios. Ele é especialmente útil quando trabalhamos com conjuntos de dados categorizados, como medidas florestais agrupadas por espécies, localizações ou períodos de tempo. 2.4.1 Dispersão condicional Imagine que temos dados sobre o diâmetro das árvores (DAP) e a altura delas em diferentes parcelas florestais. Com lattice, podemos visualizar as relações entre essas variáveis, separadas por parcelas. library(lattice) # Dados simulados set.seed(123) dados &lt;- data.frame( Parcela = factor(rep(1:3, each = 50)), DAP = c(rnorm(50, mean = 20, sd = 5), rnorm(50, mean = 25, sd = 6), rnorm(50, mean = 22, sd = 4)), Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 16, sd = 3)) ) # Gráfico de dispersão por parcela xyplot(Altura ~ DAP | Parcela, data = dados, main = &quot;Altura x DAP por Parcela&quot;, xlab = &quot;Diâmetro à Altura do Peito (DAP)&quot;, ylab = &quot;Altura (m)&quot;, col = &quot;red&quot;, pch = 16) 2.4.2 Histograma condicional Os histogramas condicionais são úteis para visualizar a distribuição do DAP em diferentes espécies de árvores. # Dados simulados dados$Especie &lt;- factor(rep(c(&quot;Espécie A&quot;, &quot;Espécie B&quot;, &quot;Espécie C&quot;), each = 50)) # Histograma por espécie histogram(~ DAP | Especie, data = dados, main = &quot;Distribuição do DAP por Espécie&quot;, xlab = &quot;Diâmetro à Altura do Peito (DAP)&quot;, col = &quot;lightblue&quot;, border = &quot;black&quot;) 2.4.3 Boxplot comparativo Os boxplots são ideais para comparar a altura das árvores entre espécies em diferentes parcelas. # Ajustando o boxplot bwplot(Altura ~ Especie | Parcela, data = dados, main = &quot;Altura por Espécie e Parcela&quot;, xlab = &quot;Espécie&quot;, ylab = &quot;Altura (m)&quot;, col = &quot;forestgreen&quot;, par.settings = list(box.rectangle = list(col = &quot;blue&quot;), plot.symbol = list(col = &quot;darkgreen&quot;, pch = 16)), scales = list(x = list(rot = 45))) # Rotação dos rótulos no eixo X 2.4.4 Barras por classes Se quisermos visualizar a contagem de árvores por espécie em cada parcela, o gráfico de barras é uma escolha apropriada. # Reorganizando os dados para melhor visualização library(reshape2) dados_barras &lt;- as.data.frame(contagem) names(dados_barras) &lt;- c(&quot;Especie&quot;, &quot;Parcela&quot;, &quot;Contagem&quot;) # Gráfico de barras mais visual barchart(Contagem ~ Especie | Parcela, data = dados_barras, main = &quot;Número de Árvores por Espécie e Parcela&quot;, xlab = &quot;Espécie&quot;, ylab = &quot;Número de Árvores&quot;, col = c(&quot;darkgreen&quot;, &quot;lightgreen&quot;, &quot;brown&quot;), auto.key = list(columns = 3), # Legenda com as espécies panel = function(x, y, ...) { panel.barchart(x, y, ...) panel.text(x, y, labels = y, pos = 3, cex = 0.8) # Rótulos numéricos }, scales = list(x = list(rot = 45))) # Rotação dos rótulos no eixo X 2.4.5 Gráficos 3D Se você trabalha com dados ambientais ou florestais que envolvem superfícies, como elevação, densidade de árvores ou biomassa em um terreno, os gráficos de superfície podem ser úteis. library(lattice) # Dados simulados set.seed(123) dados &lt;- data.frame( Parcela = factor(rep(1:3, each = 50)), # Três parcelas DAP = c(rnorm(50, mean = 20, sd = 5), rnorm(50, mean = 25, sd = 4), rnorm(50, mean = 30, sd = 6)), # Diâmetro Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 20, sd = 4)), # Altura Biomassa = c(rnorm(50, mean = 200, sd = 50), rnorm(50, mean = 300, sd = 40), rnorm(50, mean = 400, sd = 60)) # Biomassa ) # Gráfico 3D condicional cloud(Biomassa ~ DAP * Altura | Parcela, data = dados, main = &quot;Relação 3D: Biomassa, DAP e Altura por Parcela&quot;, xlab = &quot;Diâmetro (DAP)&quot;, ylab = &quot;Altura (m)&quot;, zlab = &quot;Biomassa (kg)&quot;, screen = list(z = 60, x = -60), # Ajuste do ângulo de visualização col = &quot;forestgreen&quot;, pch = 16) # Pontos no gráfico library(lattice) # Gerando coordenadas x e y (grid regular) x &lt;- seq(-10, 10, length = 30) # 30 pontos no eixo X y &lt;- seq(-10, 10, length = 30) # 30 pontos no eixo Y # Gerando altura (z) com base em uma função para criar uma superfície z &lt;- outer(x, y, function(x, y) x * 2) # Convertendo para um data frame para usar com cloud() dados &lt;- expand.grid(x = x, y = y) dados$z &lt;- as.vector(z) # Gráfico 3D simulando o terreno cloud(z ~ x * y, data = dados, main = &quot;Terreno Simulado em 3D&quot;, xlab = &quot;Coordenada X&quot;, ylab = &quot;Coordenada Y&quot;, zlab = &quot;Altura (Z)&quot;, screen = list(z = 60, x = -60), # Ângulo de visualização col = &quot;lightblue&quot;, # Cor dos pontos panel.3d.cloud = panel.3dscatter, # Adiciona pontos ao gráfico pch = 16) # Pontos sólidos 2.4.6 Densidade Condicional Se você deseja comparar distribuições contínuas, como a altura de árvores em diferentes regiões ou espécies, os gráficos de densidade são uma alternativa elegante aos histogramas. # Gerando dados simulados com a variável Especie set.seed(123) dados &lt;- data.frame( Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 20, sd = 4)), Especie = factor(rep(c(&quot;Espécie A&quot;, &quot;Espécie B&quot;, &quot;Espécie C&quot;), each = 50)) ) # Gráfico de densidade densityplot(~ Altura | Especie, data = dados, main = &quot;Densidade da Altura por Espécie&quot;, xlab = &quot;Altura (m)&quot;, plot.points = FALSE, # Ocultar pontos individuais col = c(&quot;blue&quot;, &quot;darkgreen&quot;, &quot;orange&quot;)) 2.4.7 Matrix de dispersão (Scatterplot Matrix) Se você tem várias variáveis numéricas e quer explorar as relações entre elas, o lattice oferece o splom() (scatterplot matrix). # Gerando os dados simulados com DAP e Altura set.seed(123) dados &lt;- data.frame( DAP = c(rnorm(50, mean = 20, sd = 5), rnorm(50, mean = 25, sd = 6), rnorm(50, mean = 30, sd = 4)), Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 20, sd = 4)) ) # Calculando a biomassa dados$Biomassa &lt;- dados$DAP * dados$Altura * rnorm(150, mean = 0.1, sd = 0.01) # Gerando o scatterplot matrix (splom) library(lattice) splom(~ dados[c(&quot;DAP&quot;, &quot;Altura&quot;, &quot;Biomassa&quot;)], main = &quot;Matriz de Dispersão&quot;, col = &quot;darkblue&quot;, pch = 16) 2.4.8 Temporal condicional Se você possui dados temporais, como crescimento de árvores ao longo de anos ou medições sazonais, os gráficos de linha com painéis são muito úteis. # Dados simulados de crescimento anual set.seed(123) anos &lt;- 2000:2020 crescimento &lt;- expand.grid(Ano = anos, Especie = c(&quot;Espécie A&quot;, &quot;Espécie B&quot;, &quot;Espécie C&quot;)) crescimento$Altura &lt;- with(crescimento, ifelse(Especie == &quot;Espécie A&quot;, rnorm(length(Ano), mean = Ano - 1995, sd = 0.5), ifelse(Especie == &quot;Espécie B&quot;, rnorm(length(Ano), mean = Ano - 1993, sd = 0.7), rnorm(length(Ano), mean = Ano - 1990, sd = 0.6)))) # Gráfico de linha com painéis xyplot(Altura ~ Ano | Especie, data = crescimento, type = &quot;o&quot;, col = &quot;darkgreen&quot;, pch = 16, main = &quot;Crescimento por Espécie ao Longo dos Anos&quot;, xlab = &quot;Ano&quot;, ylab = &quot;Altura (m)&quot;) "],["pacote-ggplot2.html", "2.5 Pacote ggplot2", " 2.5 Pacote ggplot2 O ggplot2 é um pacote poderoso para criar gráficos no R, baseado na “gramática de gráficos”. Ele permite construir visualizações claras e customizáveis, úteis em estudos florestais, como análise de biomassa, inventários florestais e distribuição de espécies. 2.5.1 Gráfico de dispersão Ideal para visualizar relações entre variáveis contínuas, como altura e diâmetro das árvores. # Dados simulados de árvores com distribuição normal set.seed(123) # Para resultados reprodutíveis DAP = rnorm(100, mean = 30, sd = 7) # DAP em cm Altura = (log(DAP) * 7.87) random_h_factor = rnorm(100, 1, 0.1) Altura = Altura * random_h_factor dados_arvores &lt;- data.frame(DAP, Altura) library(ggplot2) ggplot(data = dados_arvores, aes(x = DAP, y = Altura)) + geom_point(color = &quot;red&quot;, size = 2) + theme_minimal() Adicionando uma linha de tendência # Gráfico com ajuste linear e intervalo de confiança ggplot(data = dados_arvores, aes(x = DAP, y = Altura)) + geom_point() + geom_smooth(method = &quot;lm&quot;, formula = y ~ log(x), color = &quot;blue&quot;, se = TRUE) + labs( x = &quot;DAP (cm)&quot;, y = &quot;Altura (m)&quot; ) + theme_minimal() Dispersão condicional # Dados simulados set.seed(123) dados &lt;- data.frame( DAP = c(rnorm(50, mean = 30, sd = 5), rnorm(50, mean = 40, sd = 7)), # Diâmetro em cm Altura_Comercial = c(rnorm(50, mean = 20, sd = 3), rnorm(50, mean = 25, sd = 4)), # Altura em metros Especie = rep(c(&quot;Espécie A&quot;, &quot;Espécie B&quot;), each = 50) # Categorias de espécies ) ggplot(data = dados, aes(x = DAP, y = Altura_Comercial, color = Especie)) + geom_point(size = 3, alpha = 0.8) + # Tamanho e transparência dos pontos labs( title = &quot;Relação entre DAP e Altura Comercial por Espécie&quot;, x = &quot;DAP (cm)&quot;, y = &quot;Altura Comercial (m)&quot;, color = &quot;Espécie&quot; ) + theme_minimal() # Tema limpo 2.5.2 Gráfico de Barras # Criando classes de diâmetro dados_arvores$Classe_DAP &lt;- cut(dados_arvores$DAP, breaks = seq(10, 60, 5)) ggplot(data = dados_arvores, aes(x = Classe_DAP)) + geom_bar(fill = &quot;sienna&quot;, color = &quot;black&quot;) + labs( title = &quot;Frequência de Classes de DAP&quot;, x = &quot;Classes de DAP (cm)&quot;, y = &quot;Frequência&quot; ) + theme_bw() Adicionando classes dados_arvores$Especie &lt;- sample(c(&quot;Espécie A&quot;, &quot;Espécie B&quot;), 50, replace = TRUE) ggplot(data = dados_arvores, aes(x = Classe_DAP, fill = Especie)) + geom_bar(position = &quot;dodge&quot;, color = &quot;black&quot;) + labs( title = &quot;Frequência de Classes de DAP por Espécie&quot;, x = &quot;Classes de DAP (cm)&quot;, y = &quot;Frequência&quot;, fill = &quot;Espécie&quot; ) + theme_light() 2.5.3 Histograma dados_arvores$Biomassa &lt;- dados_arvores$DAP * dados_arvores$Altura * 0.05 ggplot(data = dados_arvores, aes(x = Biomassa)) + geom_histogram(binwidth = 2, fill = &quot;green&quot;, color = &quot;black&quot;) + labs( title = &quot;Distribuição da Biomassa das Árvores&quot;, x = &quot;Biomassa (kg)&quot;, y = &quot;Frequência&quot; ) + theme_classic() 2.5.4 Gráfico de linhas # Dados simulados set.seed(123) anos &lt;- 2000:2020 preco_madeira &lt;- cumsum(runif(length(anos), -2, 5)) + 100 # Preço acumulativo com flutuações dados_madeira &lt;- data.frame( Ano = anos, Preco = preco_madeira ) # Gráfico de linhas ggplot(data = dados_madeira, aes(x = Ano, y = Preco)) + geom_line(color = &quot;darkgreen&quot;, size = 1) + labs( title = &quot;Preços Médios da Madeira ao Longo do Tempo&quot;, x = &quot;Ano&quot;, y = &quot;Preço Médio (R$/m³)&quot; ) + theme_minimal() 2.5.5 Boxplot ggplot(data = dados_arvores, aes(x = Especie, y = DAP, fill = Especie)) + geom_boxplot() + labs( title = &quot;Distribuição do DAP por Espécie&quot;, x = &quot;Espécie&quot;, y = &quot;DAP (cm)&quot; ) + theme_light() 2.5.6 Gráficos de densidade # Dados simulados set.seed(123) dados &lt;- data.frame(Valores = rnorm(1000, mean = 50, sd = 10)) # Gráfico de densidade ggplot(data = dados, aes(x = Valores)) + geom_density(fill = &quot;blue&quot;, alpha = 0.5) + labs( title = &quot;Função de Densidade de Probabilidade&quot;, x = &quot;Valores&quot;, y = &quot;Densidade&quot; ) + theme_minimal() Combinando Histograma e densidade ggplot(data = dados, aes(x = Valores)) + geom_histogram(aes(y = after_stat(density)), binwidth = 2, fill = &quot;gray&quot;, alpha = 0.7) + geom_density(color = &quot;blue&quot;, size = 1) + labs( title = &quot;Histograma com Função de Densidade&quot;, x = &quot;Valores&quot;, y = &quot;Densidade&quot; ) + theme_minimal() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
