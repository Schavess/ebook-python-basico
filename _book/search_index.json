[["index.html", "Entre Florestas e Dados Sobre", " Entre Florestas e Dados Arthur Guilherme Schirmbeck Chaves Última atualização: 2024-11-23 Sobre “Entre Florestas e Dados” é um livro digital dinâmico (sempre atualizado online) que compartilha soluções práticas para análises de dados florestais utilizando a linguagem R. Por que este livro? Este livro foi criado para preencher uma lacuna na literatura sobre análise de dados aplicada especificamente ao setor florestal, com o intuito de capacitar profissionais a tomar decisões fundamentadas em dados de inventários, planejamento e monitoramento ambiental. Autor Olá! Meu nome é Arthur Guilherme Schirmbeck Chaves. Sou professor de Engenharia Florestal no IFMT. Como engenheiro florestal e analista de sistemas com sólida experiência em planejamento florestal, inventário, silvicultura e análise de dados, estou desenvolvendo este livro para compartilhar soluções práticas e orientadas por dados para os engenheiros florestais empregarem em suas atividades profissionais e didáticas. "],["introdução-ao-r.html", "1 Introdução ao R", " 1 Introdução ao R O R é provavelmente a mais importante ferramenta para a análise de dados florestais. Neste capítulo trataremos sobre: Instalação do R e do RStudio; Fundamentos da linguagem; Arrays e Dataframes; Listas; Funções; Gerenciamento de pacotes; Importação e exportação de dados. Gráficos básicos no R "],["instalação.html", "1.1 Instalação", " 1.1 Instalação 1.1.1 Instalação do R A instalação padrão do R é feita a partir do CRAN, uma rede de servidores espalhada pelo mundo que armazena versões idênticas e atualizadas de códigos e documentações para o R. 1.1.1.1 Windows Para instalar o R no Windows, siga os seguintes passos: Acesse o CRAN: https://www.r-project.org/ No menu à esquerda, encontre a opção Download e clique em CRAN. Escolha a opção de servidor (mirror) mais próxima de você. Clique em Download R for Windows. Clique na opção base. Na nova página, clique em Download R x.x.x for Windows, sendo x.x.x o número da versão que será baixada. Se você teve algum problema com o download, tente escolher outro servidor no passo 3. Feito o download, clique duas vezes no arquivo baixado e siga as instruções para instalação. 1.1.1.2 macOS Abra o terminal: Command + Espaço “terminal” e Enter brew install --cask r 1.1.1.3 Linux Abra o terminal Linux: ctrl + alt + t sudo apt update sudo apt upgrade sudo apt install -y r-base 1.1.2 Instalação do RStudio Para instalar o RStudio, siga os passos atualizados abaixo: Acesse a página de downloads do RStudio: Visite https://posit.co/download/rstudio-desktop/#download. Verifique os requisitos do sistema: Certifique-se de que seu sistema operacional é compatível: Windows: Windows 10 ou superior (64 bits). macOS: macOS 11 (Big Sur) ou superior. Linux: Distribuições compatíveis incluem Debian 10, Ubuntu 18.04 LTS, Ubuntu 20.04 LTS, Ubuntu 22.04 LTS, Debian 9, RHEL/CentOS 7, RHEL 8 e OpenSUSE/SLES 15. Baixe o instalador adequado: Na seção “All Installers”, selecione o instalador correspondente ao seu sistema operacional. Instale o RStudio: 1.1.2.1 Windows Execute o arquivo .exe baixado e siga as instruções do assistente de instalação. 1.1.2.2 macOS Abra o arquivo .dmg baixado, arraste o ícone do RStudio para a pasta “Aplicativos” e, em seguida, ejete a imagem de disco. 1.1.2.3 Linux Baixe o pacote apropriado (.deb ou .rpm) e instale-o usando as ferramentas de gerenciamento de pacotes do seu sistema. Inicie o RStudio: Após a instalação, abra o RStudio para começar a utilizá-lo. Lembre-se de que o RStudio requer o R instalado previamente. Certifique-se de ter o R instalado antes de prosseguir com a instalação do RStudio. "],["fundamentos-da-linguagem.html", "1.2 Fundamentos da linguagem", " 1.2 Fundamentos da linguagem Uma linguagem de programação é uma forma padronizada de comunicar instruções a um computador. É como uma língua que permite aos programadores escreverem códigos que são convertidos em ações executáveis pelo computador, permitindo a criação de software, aplicativos, websites, e muito mais. Cada linguagem de programação tem sua própria sintaxe e regras, assim como as línguas humanas têm gramática e vocabulário. 1.2.1 R  R é uma linguagem de programação voltada para análise estatística e visualização de dados. Ela permite: - Manipulação de grandes volumes de dados  - Criação de gráficos avançados  - Modelagem estatística complexa  Com uma vasta comunidade e milhares de pacotes disponíveis, R é ideal tanto para iniciantes quanto para especialistas em ciência de dados. Alto Nível: R é uma linguagem de programação de alto nível projetada para abstrair detalhes técnicos e permitir que os usuários se concentrem na análise de dados e estatísticas. Ela automatiza tarefas como alocação de memória e manipulação de estruturas complexas, permitindo maior foco nos problemas analíticos e menos em detalhes de implementação. Foco em Análise de Dados: Diferentemente de linguagens de propósito geral, R é especialmente projetada para análise estatística, ciência de dados e visualização. É amplamente usada em áreas como bioestatística, econometria, aprendizado de máquina e pesquisa acadêmica, fornecendo ferramentas especializadas para cada etapa do fluxo de trabalho analítico. Visualizações Avançadas: R é reconhecida por sua capacidade de criar gráficos e visualizações de dados de alta qualidade, tanto para análises exploratórias quanto para apresentações profissionais. Com pacotes como ggplot2 e plotly, é possível produzir desde gráficos básicos até visualizações interativas complexas. Tipagem Dinâmica e Flexibilidade: R utiliza tipagem dinâmica, onde o tipo das variáveis é determinado em tempo de execução. Isso oferece flexibilidade para manipular diferentes tipos de dados, mas requer atenção para evitar inconsistências. Além disso, sua sintaxe foi projetada para facilitar operações vetoriais e manipulação de dados em larga escala, tornando-a eficiente em tarefas analíticas. 1.2.2 Boas práticas de codaR 1.2.2.1 O Básico Acesse no menu superior tools &gt; Global Options... &gt; code &gt; Display e defina os padrões de identação e estilização que deseja. E Salve. Agora basta selecionar o trecho de código e usar o atalho Ctrl + shift + A(Windows). 1.2.2.2 Avançado Para um estudo profundo verificar: O manual de referências de boas práticas (Wickham e contributors 2021) 1.2.3 ?Dúvidas ?mean # ou help(mean) 1.2.4 Tipos de dados Conhecer os tipos de dados utilizados pela linguagem é essencial para sua manipulação e análise. A seguir, estão os principais tipos de dados: Tipo Descrição Exemplo numeric Números, incluindo inteiros e reais 10, 10.5 integer Números inteiros as.integer(10) character Cadeias de caracteres (texto) \"Olá\" logical Valores booleanos TRUE, FALSE complex Números complexos 1+2i factor Variáveis categóricas factor(c(\"A\", \"B\", \"A\")) list Lista de elementos heterogêneos list(1, \"a\", TRUE) data.frame Tabela de dados estruturados data.frame(x = 1:3, y = 4:6) matrix Tabela de dados bidimensional matrix(1:6, nrow = 2) array Dados com mais de duas dimensões array(1:8, dim = c(2, 2, 2)) NULL Representa a ausência de valor NULL NA Valor ausente ou indefinido NA 1.2.5 Operadores Há inúmeras operações que podem ser realizadas com os dados dentro da lógica da programação. A seguir, estão os principais operadores: Categoria Operador Descrição Exemplo Aritmético + Adição x + y - Subtração x - y * Multiplicação x * y / Divisão x / y ^ Exponenciação x ^ y %% Módulo (resto da divisão) x %% y %/% Divisão inteira x %/% y Comparação == Igual a x == y != Diferente de x != y &gt; Maior que x &gt; y &lt; Menor que x &lt; y &gt;= Maior ou igual a x &gt;= y &lt;= Menor ou igual a x &lt;= y Lógico &amp; AND elemento por elemento x &amp; y | OR elemento por elemento x | y &amp;&amp; AND para o primeiro elemento x &amp;&amp; y | | OR para o primeiro elemento x | | y ! NOT lógico !x Atribuição &lt;- Atribui um valor x &lt;- y -&gt; Atribui um valor y -&gt; x = Atribui um valor x = y Pertencimento %in% Pertencimento (contém) x %in% y Bit a bit bitwAnd() AND bit a bit bitwAnd(x, y) bitwOr() OR bit a bit bitwOr(x, y) bitwXor() XOR bit a bit bitwXor(x, y) bitwNot() NOT bit a bit bitwNot(x) bitwShiftL() Deslocamento à esquerda bitwShiftL(x, n) bitwShiftR() Deslocamento à direita bitwShiftR(x, n) 1.2.6 Conversão de tipos Por se tratar de uma linguagem de tipagem dinâmica, é possível converter os tipos de dados: Função Descrição Exemplo Resultado as.numeric() Converte para tipo numérico as.numeric(\"10.5\") 10.5 (numeric) as.integer() Converte para inteiro as.integer(10.5) 10 (integer) as.character() Converte para texto (character) as.character(10) \"10\" (character) as.logical() Converte para lógico (booleano) as.logical(1) TRUE (logical) as.logical(0) FALSE (logical) as.complex() Converte para número complexo as.complex(10) 10+0i (complex) as.factor() Converte para fator (categorias) as.factor(c(\"A\", \"B\")) Factor com níveis as.list() Converte para lista as.list(c(1, 2, 3)) list(1, 2, 3) as.matrix() Converte para matriz as.matrix(c(1, 2, 3)) matrix (2D) as.data.frame() Converte para data frame as.data.frame(matrix(1:4, ncol=2)) data.frame as.Date() Converte para data (classe Date) as.Date(\"2024-11-18\") 2024-11-18 (Date) as.POSIXct() Converte para data/hora as.POSIXct(\"2024-11-18 10:00:00\") Data/hora (POSIXct) as.vector() Converte para vetor as.vector(matrix(1:4, nrow=2)) c(1, 2, 3, 4) as.array() Converte para array (multi-dimensional) as.array(1:8) array is.numeric() Testa se é numérico is.numeric(10.5) TRUE is.character() Testa se é texto is.character(\"text\") TRUE is.logical() Testa se é lógico is.logical(TRUE) TRUE is.factor() Testa se é fator is.factor(as.factor(\"A\")) TRUE 1.2.7 Estruturas de Controle A lógica da programação e a construção de algoritmos dependem das estruturas de controle: Estrutura Descrição Exemplo if Executa um bloco de código se a condição for verdadeira if (x &gt; 0) { print(\"Positivo\") } if-else Executa um bloco se a condição for verdadeira e outro se for falsa if (x &gt; 0) { print(\"Positivo\") } else { print(\"Negativo\") } ifelse Avaliação vetorizada para condicional result &lt;- ifelse(x &gt; 0, \"Positivo\", \"Negativo\") for Itera sobre elementos de um vetor ou lista for (i in 1:5) { print(i) } while Executa um bloco enquanto a condição for verdadeira while (x &lt; 5) { print(x); x &lt;- x + 1 } repeat Executa um bloco até encontrar um break repeat { if (x &gt; 5) break; print(x); x &lt;- x + 1 } break Interrompe a execução de um laço for (i in 1:5) { if (i == 3) break; print(i) } next Pula para a próxima iteração de um laço for (i in 1:5) { if (i == 3) next; print(i) } switch Seleciona uma opção com base em uma expressão switch(x, \"a\" = \"Opção A\", \"b\" = \"Opção B\") Funções anônimas Executa expressões diretamente em chamadas sapply(1:5, function(x) x^2) try Captura erros em blocos de código try({ log(\"a\") }) tryCatch Captura e lida com erros e mensagens tryCatch(log(\"a\"), error = function(e) print(\"Erro\")) Referências Wickham, Hadley, e contributors. 2021. Tidyverse Style Guide. RStudio, PBC. https://style.tidyverse.org/. "],["arrays-e-dataframes.html", "1.3 Arrays e Dataframes", " 1.3 Arrays e Dataframes 1.3.1 Vetor Um vetor é a estrutura mais básica no R. Ele representa um array unidimensional que armazena elementos do mesmo tipo (numérico, lógico, caractere, etc.). Podemos criar vetores usando a função c(). # Criando vetores de diferentes tipos vetor_numerico &lt;- c(1, 2, 3, 4, 5) vetor_caractere &lt;- c(&quot;Maçã&quot;, &quot;Banana&quot;, &quot;Laranja&quot;, &quot;Goiaba&quot;) vetor_logico &lt;- c(TRUE, FALSE, TRUE) # Visualizando os vetores print(vetor_numerico) ## [1] 1 2 3 4 5 print(vetor_caractere) ## [1] &quot;Maçã&quot; &quot;Banana&quot; &quot;Laranja&quot; &quot;Goiaba&quot; print(vetor_logico) ## [1] TRUE FALSE TRUE # Comprimento do vetor length(vetor_numerico) ## [1] 5 ATENÇÃO: no R, a indexação começa em 1 (ao contrário de muitas outras linguagens como Python, C ou JavaScript, que utilizam a indexação a partir de 0). # Acessando o primeiro elemento do vetor vetor_caractere[1] ## [1] &quot;Maçã&quot; # Acessando os 3 primeiros elementos vetor_caractere[1:3] ## [1] &quot;Maçã&quot; &quot;Banana&quot; &quot;Laranja&quot; # Acessando uma lista de elementos vetor_caractere[c(1,4)] ## [1] &quot;Maçã&quot; &quot;Goiaba&quot; 1.3.2 Matrix (Array 2D) a &lt;- seq(from=1, to=6) b &lt;- seq(from=1, to=10) # Criando matrizes A &lt;- matrix(a, nrow = 2, ncol = 3, byrow = TRUE) print(A) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 # Dimensão da Matrix dim(A) ## [1] 2 3 B &lt;- matrix(b, nrow = 5, ncol = 2, byrow = FALSE) print(B) ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 # Dimensão da Matrix dim(B) ## [1] 5 2 # Acessando a segunda Coluna de B print(B[, 2]) ## [1] 6 7 8 9 10 # Acessando a primeira linha de A print(A[1,]) ## [1] 1 2 3 1.3.3 Arrays multidimensionais Um array em R é uma estrutura de dados multidimensional que pode armazenar elementos de um único tipo (númerico, caractere, etc.). Ele é como uma extensão de vetores, podendo ter duas ou mais dimensões. 1.3.3.1 Criando Arrays Para criar um array, usamos a função array(). # Criando um array 3x3x2 meu_array &lt;- array(data = 1:18, dim = c(3, 3, 2)) # Visualizando o array print(meu_array) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 O exemplo acima cria um array com 3 linhas, 3 colunas e 2 “camadas”. 1.3.3.2 Acessando elementos Os elementos em arrays podem ser acessados usando índices. # Acessar o elemento na posição [1, 2, 1] meu_array[1, 2, 1] ## [1] 4 # Acessar a segunda camada inteira meu_array[, , 2] ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 1.3.4 Dataframes Os dataframes são a estrutura de dados mais comum no R para manipular tabelas de dados. Eles permitem armazenar diferentes tipos de variáveis (numéricas, categóricas, etc.) em colunas. 1.3.4.1 Criando Dataframes # Criando um dataframe meu_dataframe &lt;- data.frame( Nome = c(&quot;João&quot;, &quot;Ana&quot;, &quot;Carlos&quot;), Idade = c(25, 30, 22), Altura = c(1.75, 1.68, 1.80) ) # Visualizando o dataframe print(meu_dataframe) ## Nome Idade Altura ## 1 João 25 1.75 ## 2 Ana 30 1.68 ## 3 Carlos 22 1.80 1.3.4.2 Acessando elementos Você pode acessar linhas, colunas ou células específicas de um dataframe. # Acessar a coluna &quot;Idade&quot; meu_dataframe$Idade ## [1] 25 30 22 # Acessar a primeira linha meu_dataframe[1, ] ## Nome Idade Altura ## 1 João 25 1.75 # Acessar um elemento específico (linha 2, coluna 3) meu_dataframe[2, 3] ## [1] 1.68 1.3.4.3 Criando ou Removendo uma coluna # Adicionar uma nova coluna meu_dataframe$Peso &lt;- c(70, 60, 80) print(meu_dataframe) ## Nome Idade Altura Peso ## 1 João 25 1.75 70 ## 2 Ana 30 1.68 60 ## 3 Carlos 22 1.80 80 # Remover a coluna &quot;Peso&quot; meu_dataframe$Peso &lt;- NULL print(meu_dataframe) ## Nome Idade Altura ## 1 João 25 1.75 ## 2 Ana 30 1.68 ## 3 Carlos 22 1.80 "],["listas.html", "1.4 Listas", " 1.4 Listas As listas são estruturas mais flexíveis do que vetores ou dataframes. Uma lista pode armazenar diferentes tipos de objetos, incluindo vetores, dataframes, e até outras listas. 1.4.1 Criando listas # Criando uma lista minha_lista &lt;- list( numeros = c(1, 2, 3), nomes = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;), dataframe = meu_dataframe ) # Visualizando a lista print(minha_lista) ## $numeros ## [1] 1 2 3 ## ## $nomes ## [1] &quot;Alice&quot; &quot;Bob&quot; &quot;Carol&quot; ## ## $dataframe ## Nome Idade Altura ## 1 João 25 1.75 ## 2 Ana 30 1.68 ## 3 Carlos 22 1.80 1.4.2 Acessando Elementos de Listas Os elementos de uma lista podem ser acessados por índices ou nomes. # Acessar o primeiro elemento minha_lista[[1]] ## [1] 1 2 3 # Acessar pelo nome minha_lista$numeros ## [1] 1 2 3 # Acessar elementos dentro de um dataframe armazenado minha_lista$dataframe$Idade ## [1] 25 30 22 1.4.3 Dataframe vs. Lista Embora um dataframe seja tecnicamente uma lista, ele é estruturado de maneira que todas as colunas tenham o mesmo número de elementos e seja mais simples de trabalhar com dados tabulares. Já as listas são muito mais flexíveis. Característica Dataframe Lista Estrutura Tabela (linhas e colunas) Estrutura hierárquica Tipos de dados Colunas podem ter tipos diferentes Elementos podem ser de qualquer tipo, incluindo listas ou dataframes Indexação Por linhas e colunas Por índices ou nomes Uso típico Dados tabulares Agrupamento de objetos heterogêneos "],["funções.html", "1.5 Funções", " 1.5 Funções Uma função é um bloco de código que realiza uma tarefa específica. Ela recebe entradas (argumentos), processa os dados e retorna um resultado. Exemplo de Função # Função simples para calcular a soma de dois números soma &lt;- function(x, y) { resultado &lt;- x + y return(resultado) } # Usando a função soma(2, 3) # Resultado: 5 ## [1] 5 1.5.1 Usando funções O R oferece várias funções embutidas para realizar tarefas comuns. Aqui estão alguns exemplos: Funções matemáticas # Funções básicas sqrt(16) # Raiz quadrada: 4 ## [1] 4 log(10) # Logaritmo natural ## [1] 2.302585 round(3.1415, 2) # Arredondar para 2 casas decimais: 3.14 ## [1] 3.14 Funções estatísticas # Conjunto de dados dados &lt;- c(1, 2, 3, 4, 5) # Estatísticas básicas mean(dados) # Média: 3 ## [1] 3 median(dados) # Mediana: 3 ## [1] 3 sd(dados) # Desvio padrão ## [1] 1.581139 Funções de manipulação de strings # Manipulando texto texto &lt;- &quot;Programar no R é divertido!&quot; nchar(texto) # Número de caracteres: 27 ## [1] 27 toupper(texto) # Tudo maiúsculo ## [1] &quot;PROGRAMAR NO R É DIVERTIDO!&quot; tolower(texto) # Tudo minúsculo ## [1] &quot;programar no r é divertido!&quot; 1.5.2 Criando funções Estrutura: nome_da_funcao &lt;- function(argumento1, argumento2, ...) { # Corpo da função (o que será feito) resultado &lt;- argumento1 + argumento2 # Exemplo return(resultado) # O que será retornado } Exemplos: 1.5.2.1 Função com 1 argumentos # Função quadrado (1 argumento) quadrado &lt;- function(x) { return(x^2) } quadrado(4) ## [1] 16 1.5.2.2 Função com dois argumentos # Calcula o volume de um cilindro (2 argumentos) volume_cilindro &lt;- function(raio, altura) { volume &lt;- pi * raio^2 * altura return(volume) } # Usando a função com os argumentos volume_cilindro(raio = 3, altura = 5) # Resultado: 141.37 ## [1] 141.3717 # ou usando a função pela ordem dos argumentos volume_cilindro(3, 5) # Resultado: 141.37 ## [1] 141.3717 1.5.3 Argumentos padrão (default) Você pode definir valores padrão para os argumentos, tornando-os opcionais ao chamar a função. # Função com argumento padrão saudacao &lt;- function(nome = &quot;Visitante&quot;) { return(paste(&quot;Olá,&quot;, nome, &quot;!&quot;)) } # Chamadas da função saudacao(&quot;Maria&quot;) # Resultado: &quot;Olá, Maria !&quot; saudacao() # Resultado: &quot;Olá, Visitante !&quot; 1.5.4 Função anônima A função será executada somente naquele instante; não havendo necessidade de se nomeá-la. No javascript são conhecidas como arrow functions. # Função anônima em apply() vetor &lt;- c(1, 2, 3, 4) resultado &lt;- sapply(vetor, function(x) x^2) print(resultado) # Resultado: [1] 1 4 9 16 "],["gerenciamento-de-pacotes.html", "1.6 Gerenciamento de Pacotes ", " 1.6 Gerenciamento de Pacotes  O R é uma linguagem poderosa, ampliada pelo uso de pacotes. Com pacotes, é possível adicionar novas funcionalidades e acessar ferramentas específicas para diversas tarefas, como visualização de dados, manipulação e modelagem estatística. 1.6.1 O que são pacotes? Pacotes no R são coleções de funções, conjuntos de dados e documentações. Eles estendem as funcionalidades do R base e são fundamentais para tarefas mais avançadas. Os pacotes podem ser obtidos do CRAN (repositório oficial), GitHub ou outras fontes. Pacotes populares incluem ggplot2 (gráficos), dplyr (manipulação de dados) e shiny (aplicações interativas). 1.6.2 Instalando pacotes Para instalar pacotes no R, utilize a função install.packages(). 1.6.2.1 Exemplo básico: # Instalando um pacote do CRAN install.packages(&quot;ggplot2&quot;) 1.6.2.2 Instalando múltiplos pacotes: install.packages(c(&quot;dplyr&quot;, &quot;tidyr&quot;, &quot;stringr&quot;)) 1.6.2.3 Instalando pacotes do GitHub: Pacotes disponíveis no GitHub requerem o pacote remotes ou devtools para instalação: # Instalando o pacote remotes install.packages(&quot;remotes&quot;) # Instalando um pacote do GitHub remotes::install_github(&quot;tidyverse/ggplot2&quot;) 1.6.3 Carregando pacotes Depois de instalados, os pacotes precisam ser carregados para uso. Isso é feito com a função library(). 1.6.3.1 Exemplo: # Carregando o pacote ggplot2 library(ggplot2) Se você não quiser carregar o pacote inteiro, pode usar o operador :: para chamar uma função específica: # Usando a função ggplot() sem carregar o pacote ggplot2::ggplot(data = mtcars, aes(x = mpg, y = hp)) 1.6.4 Atualizando pacotes Pacotes instalados podem ser atualizados para suas versões mais recentes. 1.6.4.1 Atualizando todos os pacotes: update.packages() 1.6.4.2 Atualizando pacotes específicos: Reinstale o pacote desejado: install.packages(&quot;dplyr&quot;) 1.6.5 Removendo pacotes Se um pacote não for mais necessário, você pode removê-lo com a função remove.packages(). 1.6.5.1 Exemplo: remove.packages(&quot;stringr&quot;) 1.6.6 Verificando pacotes instalados Você pode listar todos os pacotes instalados ou verificar se um pacote específico está presente. 1.6.6.1 Listando todos os pacotes: installed.packages() 1.6.6.2 Verificando se um pacote está instalado: &quot;ggplot2&quot; %in% rownames(installed.packages()) 1.6.7 Repositórios O R utiliza o CRAN como repositório padrão para instalação de pacotes. No entanto, você pode configurar o repositório manualmente, por exemplo, escolhendo um mirror mais rápido: # Configurando um repositório brasileiro options(repos = c(CRAN = &quot;https://cran.rstudio.com/&quot;)) 1.6.8 Ferramentas avançadas para gerenciamento Para projetos complexos, você pode usar ferramentas para gerenciar versões de pacotes e ambientes: renv: Cria ambientes isolados para projetos, garantindo que as dependências permaneçam consistentes: install.packages(&quot;renv&quot;) renv::init() packrat: Alternativa mais antiga ao renv, também para isolamento de dependências. conda: Se você utiliza Python junto com R, o conda permite gerenciar pacotes R em ambientes híbridos. "],["importação-e-exportação-de-dados.html", "1.7 Importação e Exportação de Dados ", " 1.7 Importação e Exportação de Dados  O R oferece diversas ferramentas para importar e exportar dados em diferentes formatos, permitindo que você trabalhe com arquivos como CSV, Excel, bancos de dados, arquivos de texto e muito mais. 1.7.1 Importando dados 1.7.1.1 1. Arquivos CSV O formato CSV é amplamente utilizado e facilmente manipulável no R com a função read.csv() ou a função mais moderna readr::read_csv(). # Usando a função base dados &lt;- read.csv(&quot;caminho/para/seu/arquivo.csv&quot;) # Usando o pacote readr (do Tidyverse) dados &lt;- readr::read_csv(&quot;caminho/para/seu/arquivo.csv&quot;) 1.7.1.2 2. Arquivos Excel Para importar dados de planilhas Excel, você pode usar pacotes como readxl ou openxlsx. # Instale o pacote readxl, se necessário install.packages(&quot;readxl&quot;) # Lendo uma planilha Excel library(readxl) dados &lt;- read_excel(&quot;caminho/para/seu/arquivo.xlsx&quot;, sheet = 1) 1.7.1.3 3. Arquivos de texto Para arquivos de texto delimitados (como TSV), use read.delim() ou readr::read_tsv(). # Arquivo delimitado por tabulação dados &lt;- read.delim(&quot;caminho/para/seu/arquivo.txt&quot;) # Com readr dados &lt;- readr::read_tsv(&quot;caminho/para/seu/arquivo.txt&quot;) 1.7.1.4 4. Bancos de Dados Para se conectar a bancos de dados, use pacotes como DBI e RSQLite. # Exemplo com SQLite install.packages(&quot;DBI&quot;) install.packages(&quot;RSQLite&quot;) library(DBI) con &lt;- dbConnect(RSQLite::SQLite(), &quot;caminho/para/seu/banco.sqlite&quot;) dados &lt;- dbReadTable(con, &quot;nome_da_tabela&quot;) dbDisconnect(con) 1.7.1.5 5. Outros formatos populares JSON: Use o pacote jsonlite. XML: Use o pacote xml2. Arquivos SPSS, Stata e SAS: Use o pacote haven. # Exemplo de JSON install.packages(&quot;jsonlite&quot;) dados &lt;- jsonlite::fromJSON(&quot;caminho/para/seu/arquivo.json&quot;) 1.7.2 Exportando dados 1.7.2.1 1. Exportando para CSV A função write.csv() é usada para salvar dados em formato CSV. # Salvando um data frame como CSV write.csv(dados, &quot;caminho/para/saida.csv&quot;, row.names = FALSE) 1.7.2.2 2. Exportando para Excel Para salvar dados em Excel, use o pacote openxlsx. # Instale o pacote openxlsx, se necessário install.packages(&quot;openxlsx&quot;) # Escrevendo dados em uma planilha Excel library(openxlsx) write.xlsx(dados, &quot;caminho/para/saida.xlsx&quot;) 1.7.2.3 3. Exportando para outros formatos O R permite salvar dados em diversos formatos com as funções correspondentes: - Texto (write.table()) - JSON (jsonlite::toJSON()) - Bancos de dados (dbWriteTable()). Exemplo com JSON: jsonlite::toJSON(dados, pretty = TRUE, file = &quot;caminho/para/saida.json&quot;) 1.7.3 Dicas e boas práticas Sempre verifique os tipos de dados importados com str() ou glimpse(). Para grandes volumes de dados, considere pacotes otimizados como data.table ou vroom. Configure o diretório de trabalho corretamente para evitar erros de caminho: setwd(&quot;caminho/para/seu/diretorio&quot;) "],["gráficos-básicos.html", "1.8 Gráficos básicos", " 1.8 Gráficos básicos Os gráficos são ferramentas fundamentais para analisar e comunicar dados de forma eficiente. No R, a criação de gráficos padrão é extremamente acessível, permitindo a geração de visualizações informativas com poucos comandos. Esses gráficos servem como ponto de partida para análises exploratórias e também para apresentações mais refinadas. 1.8.1 Gráficos de dispersão Um dos gráficos mais utilizados para visualizar a relação entre duas variáveis. # Exemplo de gráfico de dispersão x &lt;- rnorm(100) y &lt;- x + rnorm(100, sd = 0.5) plot(x, y, main = &quot;Gráfico de Dispersão&quot;, xlab = &quot;Eixo X&quot;, ylab = &quot;Eixo Y&quot;) 1.8.2 Histograma Excelente para visualizar a distribuição de uma variável numérica. # Exemplo de histograma dados &lt;- rnorm(1000) hist(dados, main = &quot;Histograma&quot;, xlab = &quot;Valores&quot;, col = &quot;lightblue&quot;, border = &quot;black&quot;) 1.8.3 Boxplot Perfeito para comparar distribuições entre grupos. # Exemplo de boxplot grupo &lt;- factor(rep(c(&quot;A&quot;, &quot;B&quot;), each = 50)) valores &lt;- c(rnorm(50, mean = 5), rnorm(50, mean = 7)) boxplot(valores ~ grupo, main = &quot;Boxplot por Grupo&quot;, col = c(&quot;orange&quot;, &quot;lightgreen&quot;)) 1.8.4 Gráficos de pizza Embora não seja o preferido para análise quantitativa, o gráfico de pizza é útil para exibir proporções. # Exemplo de gráfico de pizza valores &lt;- c(40, 25, 20, 15) categorias &lt;- c(&quot;Categoria A&quot;, &quot;Categoria B&quot;, &quot;Categoria C&quot;, &quot;Categoria D&quot;) pie(valores, labels = categorias, main = &quot;Gráfico de Pizza&quot;, col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;)) 1.8.5 Personalização dos gráficos Os gráficos padrão do R podem ser ajustados para atender a diferentes necessidades. Entre os elementos que podem ser personalizados estão: - Títulos e rótulos: main, xlab, ylab. - Cores e estilos de linhas: col, lty, lwd. - Pontos e símbolos: pch, cex. Por exemplo, o gráfico de dispersão pode ser ajustado assim: plot(x, y, main = &quot;Gráfico Personalizado&quot;, xlab = &quot;Variável X&quot;, ylab = &quot;Variável Y&quot;, col = &quot;blue&quot;, pch = 16, cex = 1.2) "],["r-intermediário.html", "2 R Intermediário", " 2 R Intermediário Para aprofundar nossos conhecimentos sobre a linguagem vamos analisar: Funções da família apply(); O pacote dplyr; O pacote data.table. O pacote gráfico lattice "],["funções-da-família-apply-no-r.html", "2.1 Funções da família apply() no R", " 2.1 Funções da família apply() no R As funções da família apply() são usadas para realizar operações repetitivas em vetores, listas, matrizes e data frames de forma eficiente e vetorizada, substituindo muitos loops explícitos (for). 2.1.1 1. apply() Aplica uma função ao longo de uma margem de uma matriz ou array (linhas ou colunas). Uso: Para matrizes e arrays. Sintaxe: apply(X, MARGIN, FUN, ...) X: Matriz ou array. MARGIN: Margem a operar: 1 para linhas. 2 para colunas. FUN: Função a ser aplicada. Exemplo: # Soma das colunas de uma matriz mat &lt;- matrix(1:9, nrow = 3) apply(mat, 2, sum) # Resultado: [1] 12 15 18 # Média das linhas apply(mat, 1, mean) # Resultado: [1] 2 5 8 2.1.2 2. lapply() Aplica uma função a cada elemento de uma lista ou vetor e retorna uma lista como resultado. Uso: Para listas e vetores. Sintaxe: lapply(X, FUN, ...) Exemplo: # Quadrado de cada elemento de um vetor vec &lt;- 1:5 lapply(vec, function(x) x^2) # Resultado: [[1]] 1, [[2]] 4, [[3]] 9, [[4]] 16, [[5]] 25 # Aplicação em uma lista lst &lt;- list(a = 1:3, b = 4:6) lapply(lst, sum) # Resultado: $a 6, $b 15 2.1.3 3. sapply() Uma versão simplificada de lapply() que retorna um vetor ou matriz (se possível) em vez de uma lista. Uso: Para listas e vetores. Sintaxe: sapply(X, FUN, ...) Exemplo: # Quadrado de cada elemento vec &lt;- 1:5 sapply(vec, function(x) x^2) # Resultado: [1] 1 4 9 16 25 # Soma dos elementos em uma lista lst &lt;- list(a = 1:3, b = 4:6) sapply(lst, sum) # Resultado: [1] 6 15 2.1.4 4. vapply() Semelhante a sapply(), mas requer que você especifique o tipo de retorno esperado (mais seguro). Uso: Para listas e vetores. Sintaxe: vapply(X, FUN, FUN.VALUE, ...) FUN.VALUE: Define o tipo e formato esperado do retorno. Exemplo: # Soma dos elementos em uma lista com tipo esperado (numeric) lst &lt;- list(a = 1:3, b = 4:6) vapply(lst, sum, numeric(1)) # Resultado: [1] 6 15 2.1.5 5. mapply() Aplica uma função a múltiplos argumentos/vetores simultaneamente (como um map em Python). Uso: Para múltiplos vetores ou listas. Sintaxe: mapply(FUN, ..., MoreArgs = NULL) Exemplo: # Soma de dois vetores vec1 &lt;- 1:5 vec2 &lt;- 6:10 mapply(sum, vec1, vec2) # Resultado: [1] 7 9 11 13 15 # Repetição customizada mapply(rep, 1:3, 3:1) # Resultado: [[1]] 1, [[2]] 2 2, [[3]] 3 3 3 2.1.6 6. tapply() Aplica uma função a subconjuntos de um vetor, definidos por um fator ou grupos. Uso: Para agrupamento. Sintaxe: tapply(X, INDEX, FUN, ...) X: Vetor numérico. INDEX: Fator ou lista de fatores para agrupar. Exemplo: # Média por grupo vec &lt;- c(1, 2, 3, 4, 5, 6) grp &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;)) tapply(vec, grp, mean) # Resultado: $A 1.5, $B 3.5, $C 5.5 2.1.7 7. by() Semelhante a tapply(), mas retorna resultados organizados por subgrupos e funciona com data frames. Uso: Para data frames. Sintaxe: by(data, INDICES, FUN, ...) Exemplo: # Soma dos valores por grupo em um data frame df &lt;- data.frame(value = 1:6, group = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;)) by(df$value, df$group, sum) # Resultado: # A: 3 # B: 7 # C: 11 Conclusão As funções da família apply() tornam o R extremamente poderoso e eficiente para manipulação de dados. Use: - apply() para matrizes/arrays. - lapply() e sapply() para listas/vetores. - mapply() para múltiplos vetores. - tapply() e by() para agrupamentos. "],["dplyr.html", "2.2 dplyr", " 2.2 dplyr O pacote dplyr é uma das ferramentas mais populares do ecossistema R para manipulação de dados. Ele fornece uma sintaxe simples e eficiente para tarefas como filtragem, ordenação, agrupamento e transformação de dados. Neste capítulo, exploraremos as principais funções do dplyr aplicadas a um conjunto de dados florestais. 2.2.1 O que é o Pipe %&gt;%? O operador %&gt;% é chamado de pipe. Ele permite encadear funções de maneira a facilitar a leitura e compreensão do código. Ao invés de ficar atribuindo valores intermediários ou aninhando várias funções, você simplesmente passa o resultado de uma função como entrada para a próxima. 2.2.1.1 Exemplos de Uso Vamos usar o conjunto de dados mtcars para entender como o pipe facilita a manipulação de dados: Sem %&gt;% (Sem Pipe) Imagine que queremos fazer as seguintes operações no dataset mtcars: Filtrar apenas os carros que têm mais de 20 milhas por galão (mpg &gt; 20). Selecionar apenas as colunas mpg, cyl, e hp. Sem o operador %&gt;%, o código ficaria assim: library(dplyr) # Sem pipe filtered_data &lt;- filter(mtcars, mpg &gt; 20) selected_data &lt;- select(filtered_data, mpg, cyl, hp) Com %&gt;% (Com Pipe) Podemos simplificar isso usando o pipe: library(dplyr) # Usando pipe selected_data &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) mpg cyl hp Mazda RX4 21.0 6 110 Mazda RX4 Wag 21.0 6 110 Datsun 710 22.8 4 93 Hornet 4 Drive 21.4 6 110 Merc 240D 24.4 4 62 Merc 230 22.8 4 95 Note como o código com %&gt;% é mais legível e direto. Ele segue uma lógica sequencial que permite facilmente entender o que está sendo feito em cada etapa. 2.2.2 Tibbles Tibbles são data frames com ajustes que os deixam mais amigáveis aos cientistas de dados. Elas são parte do pacote {tibble}. Assim, para começar a usá-las, instale e carregue o pacote. install.packages(&quot;tibble&quot;) library(tibble) Criando um exemplo: # Criando um exemplo de dados florestais library(dplyr) dados_florestais &lt;- tibble::tibble( parcela = rep(1:5, each = 10), especie = sample(c(&quot;Cedro&quot;, &quot;Ipê&quot;, &quot;Jatobá&quot;, &quot;Angelim&quot;, &quot;Castanheira&quot;), 50, replace = TRUE), dap_cm = round(runif(50, 10, 80), 1), # Diâmetro em cm altura_m = round(runif(50, 5, 30), 1), # Altura em metros volume_m3 = dap_cm * altura_m * 0.00007854 # Fórmula fictícia para volume ) dados_florestais ## # A tibble: 50 × 5 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Angelim 45.1 27.5 0.0974 ## 2 1 Jatobá 46.4 16.2 0.0590 ## 3 1 Ipê 59.3 15.8 0.0736 ## 4 1 Ipê 43.4 15.4 0.0525 ## 5 1 Jatobá 30.6 12.9 0.0310 ## 6 1 Castanheira 47.5 8.5 0.0317 ## 7 1 Cedro 51.2 24.8 0.0997 ## 8 1 Castanheira 56.2 26 0.115 ## 9 1 Cedro 76.9 9.8 0.0592 ## 10 1 Jatobá 29 16.4 0.0374 ## # ℹ 40 more rows 2.2.3 filter() Podemos filtrar árvores de uma espécie específica ou com características particulares. Exemplo: selecionar árvores com DAP maior que 50 cm. # Filtrando árvores com DAP &gt; 50 cm arvores_grandes &lt;- dados_florestais %&gt;% filter(dap_cm &gt; 50) head(arvores_grandes) ## # A tibble: 6 × 5 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Ipê 59.3 15.8 0.0736 ## 2 1 Cedro 51.2 24.8 0.0997 ## 3 1 Castanheira 56.2 26 0.115 ## 4 1 Cedro 76.9 9.8 0.0592 ## 5 2 Ipê 53.7 29.9 0.126 ## 6 3 Ipê 58.3 5.9 0.0270 2.2.4 select() Para trabalhar com um subconjunto de variáveis, podemos usar select(). Exemplo: selecionar apenas as colunas especie, dap_cm e altura_m. # Selecionando colunas específicas dados_selecionados &lt;- dados_florestais %&gt;% select(especie, dap_cm, altura_m) head(dados_selecionados) ## # A tibble: 6 × 3 ## especie dap_cm altura_m ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Angelim 45.1 27.5 ## 2 Jatobá 46.4 16.2 ## 3 Ipê 59.3 15.8 ## 4 Ipê 43.4 15.4 ## 5 Jatobá 30.6 12.9 ## 6 Castanheira 47.5 8.5 2.2.5 mutate() Podemos criar novas variáveis com base em cálculos. Exemplo: calcular o índice de esbeltez (altura/DAP). # Adicionando o índice de esbeltez dados_florestais &lt;- dados_florestais %&gt;% mutate(indice_esbeltez = altura_m / dap_cm) head(dados_florestais) ## # A tibble: 6 × 6 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Angelim 45.1 27.5 0.0974 ## 2 1 Jatobá 46.4 16.2 0.0590 ## 3 1 Ipê 59.3 15.8 0.0736 ## 4 1 Ipê 43.4 15.4 0.0525 ## 5 1 Jatobá 30.6 12.9 0.0310 ## 6 1 Castanheira 47.5 8.5 0.0317 ## # ℹ 1 more variable: indice_esbeltez &lt;dbl&gt; 2.2.6 arrange() Para ordenar as árvores pelo DAP em ordem decrescente: # Ordenando por DAP dados_ordenados &lt;- dados_florestais %&gt;% arrange(desc(dap_cm)) head(dados_ordenados) ## # A tibble: 6 × 6 ## parcela especie dap_cm altura_m volume_m3 ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 Angelim 78 20.3 0.124 ## 2 1 Cedro 76.9 9.8 0.0592 ## 3 5 Angelim 73.2 24.9 0.143 ## 4 4 Castanheira 72.6 18.9 0.108 ## 5 5 Cedro 72.3 28.5 0.162 ## 6 4 Cedro 70.8 16.3 0.0906 ## # ℹ 1 more variable: indice_esbeltez &lt;dbl&gt; 2.2.7 summarise() e group_by() Agrupar e resumir dados é uma tarefa comum em análises florestais. Exemplo: calcular o DAP médio e o volume total por espécie. # Resumo por espécie resumo_especies &lt;- dados_florestais %&gt;% group_by(especie) %&gt;% summarise( dap_medio = mean(dap_cm), volume_total = sum(volume_m3) ) resumo_especies ## # A tibble: 5 × 3 ## especie dap_medio volume_total ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Angelim 50.2 0.682 ## 2 Castanheira 48.2 0.603 ## 3 Cedro 53.5 0.732 ## 4 Ipê 36.9 0.490 ## 5 Jatobá 34.9 0.387 2.2.8 ungroup() Após usar group_by() em uma análise, o objeto resultante permanece “agrupado”. Isso pode afetar operações subsequentes. Para remover o agrupamento, usamos ungroup(). Exemplo: calcular o DAP médio por espécie e, em seguida, adicionar uma coluna ao dataset original com o DAP médio total (sem agrupamento). # Resumo por espécie com agrupamento resumo_especies &lt;- dados_florestais %&gt;% group_by(especie) %&gt;% summarise(dap_medio = mean(dap_cm)) # Adicionando o DAP médio geral dap_geral &lt;- resumo_especies %&gt;% ungroup() %&gt;% summarise(dap_medio_geral = mean(dap_medio)) dap_geral ## # A tibble: 1 × 1 ## dap_medio_geral ## &lt;dbl&gt; ## 1 44.7 "],["data.html", "2.3 data.table", " 2.3 data.table 2.3.1 O que é o :=? O operador := é chamado de operador de atribuição por referência. Ele pertence ao pacote data.table e é usado para adicionar ou modificar colunas em um data.table. O := é mais eficiente do que usar &lt;- em um data.table, pois faz as modificações “por referência”, o que significa que não cria cópias desnecessárias dos dados, sendo muito mais rápido e eficiente em termos de memória. 2.3.2 Exemplos de Uso Vamos usar o pacote data.table para entender como o := funciona. Primeiro, vamos criar um data.table com alguns dados fictícios: library(data.table) # Criação de um data.table DT &lt;- data.table( id = 1:5, valor = c(10, 15, 20, 25, 30) ) Adicionando uma Nova Coluna com := Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor: DT[, valor_2 := valor * 2] print(DT) ## id valor valor_2 ## 1: 1 10 20 ## 2: 2 15 30 ## 3: 3 20 40 ## 4: 4 25 50 ## 5: 5 30 60 Modificando uma Coluna Existente com := Podemos também modificar uma coluna existente. Vamos modificar a coluna valor_2 para ser o triplo do valor da coluna valor: DT[, valor_2 := valor * 3] print(DT) ## id valor valor_2 ## 1: 1 10 30 ## 2: 2 15 45 ## 3: 3 20 60 ## 4: 4 25 75 ## 5: 5 30 90 "],["pacote-lattice.html", "2.4 Pacote lattice", " 2.4 Pacote lattice O pacote lattice é uma poderosa ferramenta para criar gráficos condicionais e exploratórios. Ele é especialmente útil quando trabalhamos com conjuntos de dados categorizados, como medidas florestais agrupadas por espécies, localizações ou períodos de tempo. 2.4.1 Dispersão condicional Imagine que temos dados sobre o diâmetro das árvores (DAP) e a altura delas em diferentes parcelas florestais. Com lattice, podemos visualizar as relações entre essas variáveis, separadas por parcelas. library(lattice) # Dados simulados set.seed(123) dados &lt;- data.frame( Parcela = factor(rep(1:3, each = 50)), DAP = c(rnorm(50, mean = 20, sd = 5), rnorm(50, mean = 25, sd = 6), rnorm(50, mean = 22, sd = 4)), Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 16, sd = 3)) ) # Gráfico de dispersão por parcela xyplot(Altura ~ DAP | Parcela, data = dados, main = &quot;Altura x DAP por Parcela&quot;, xlab = &quot;Diâmetro à Altura do Peito (DAP)&quot;, ylab = &quot;Altura (m)&quot;, col = &quot;red&quot;, pch = 16) 2.4.2 Histograma condicional Os histogramas condicionais são úteis para visualizar a distribuição do DAP em diferentes espécies de árvores. # Dados simulados dados$Especie &lt;- factor(rep(c(&quot;Espécie A&quot;, &quot;Espécie B&quot;, &quot;Espécie C&quot;), each = 50)) # Histograma por espécie histogram(~ DAP | Especie, data = dados, main = &quot;Distribuição do DAP por Espécie&quot;, xlab = &quot;Diâmetro à Altura do Peito (DAP)&quot;, col = &quot;lightblue&quot;, border = &quot;black&quot;) 2.4.3 Boxplot comparativo Os boxplots são ideais para comparar a altura das árvores entre espécies em diferentes parcelas. # Ajustando o boxplot bwplot(Altura ~ Especie | Parcela, data = dados, main = &quot;Altura por Espécie e Parcela&quot;, xlab = &quot;Espécie&quot;, ylab = &quot;Altura (m)&quot;, col = &quot;forestgreen&quot;, par.settings = list(box.rectangle = list(col = &quot;blue&quot;), plot.symbol = list(col = &quot;darkgreen&quot;, pch = 16)), scales = list(x = list(rot = 45))) # Rotação dos rótulos no eixo X 2.4.4 Barras por classes Se quisermos visualizar a contagem de árvores por espécie em cada parcela, o gráfico de barras é uma escolha apropriada. # Reorganizando os dados para melhor visualização library(reshape2) dados_barras &lt;- as.data.frame(contagem) names(dados_barras) &lt;- c(&quot;Especie&quot;, &quot;Parcela&quot;, &quot;Contagem&quot;) # Gráfico de barras mais visual barchart(Contagem ~ Especie | Parcela, data = dados_barras, main = &quot;Número de Árvores por Espécie e Parcela&quot;, xlab = &quot;Espécie&quot;, ylab = &quot;Número de Árvores&quot;, col = c(&quot;darkgreen&quot;, &quot;lightgreen&quot;, &quot;brown&quot;), auto.key = list(columns = 3), # Legenda com as espécies panel = function(x, y, ...) { panel.barchart(x, y, ...) panel.text(x, y, labels = y, pos = 3, cex = 0.8) # Rótulos numéricos }, scales = list(x = list(rot = 45))) # Rotação dos rótulos no eixo X 2.4.5 Gráficos 3D Se você trabalha com dados ambientais ou florestais que envolvem superfícies, como elevação, densidade de árvores ou biomassa em um terreno, os gráficos de superfície podem ser úteis. library(lattice) # Dados simulados set.seed(123) dados &lt;- data.frame( Parcela = factor(rep(1:3, each = 50)), # Três parcelas DAP = c(rnorm(50, mean = 20, sd = 5), rnorm(50, mean = 25, sd = 4), rnorm(50, mean = 30, sd = 6)), # Diâmetro Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 20, sd = 4)), # Altura Biomassa = c(rnorm(50, mean = 200, sd = 50), rnorm(50, mean = 300, sd = 40), rnorm(50, mean = 400, sd = 60)) # Biomassa ) # Gráfico 3D condicional cloud(Biomassa ~ DAP * Altura | Parcela, data = dados, main = &quot;Relação 3D: Biomassa, DAP e Altura por Parcela&quot;, xlab = &quot;Diâmetro (DAP)&quot;, ylab = &quot;Altura (m)&quot;, zlab = &quot;Biomassa (kg)&quot;, screen = list(z = 60, x = -60), # Ajuste do ângulo de visualização col = &quot;forestgreen&quot;, pch = 16) # Pontos no gráfico library(lattice) # Gerando coordenadas x e y (grid regular) x &lt;- seq(-10, 10, length = 30) # 30 pontos no eixo X y &lt;- seq(-10, 10, length = 30) # 30 pontos no eixo Y # Gerando altura (z) com base em uma função para criar uma superfície z &lt;- outer(x, y, function(x, y) x * 2) # Convertendo para um data frame para usar com cloud() dados &lt;- expand.grid(x = x, y = y) dados$z &lt;- as.vector(z) # Gráfico 3D simulando o terreno cloud(z ~ x * y, data = dados, main = &quot;Terreno Simulado em 3D&quot;, xlab = &quot;Coordenada X&quot;, ylab = &quot;Coordenada Y&quot;, zlab = &quot;Altura (Z)&quot;, screen = list(z = 60, x = -60), # Ângulo de visualização col = &quot;lightblue&quot;, # Cor dos pontos panel.3d.cloud = panel.3dscatter, # Adiciona pontos ao gráfico pch = 16) # Pontos sólidos 2.4.6 Densidade Condicional Se você deseja comparar distribuições contínuas, como a altura de árvores em diferentes regiões ou espécies, os gráficos de densidade são uma alternativa elegante aos histogramas. # Gerando dados simulados com a variável Especie set.seed(123) dados &lt;- data.frame( Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 20, sd = 4)), Especie = factor(rep(c(&quot;Espécie A&quot;, &quot;Espécie B&quot;, &quot;Espécie C&quot;), each = 50)) ) # Gráfico de densidade densityplot(~ Altura | Especie, data = dados, main = &quot;Densidade da Altura por Espécie&quot;, xlab = &quot;Altura (m)&quot;, plot.points = FALSE, # Ocultar pontos individuais col = c(&quot;blue&quot;, &quot;darkgreen&quot;, &quot;orange&quot;)) 2.4.7 Matrix de dispersão (Scatterplot Matrix) Se você tem várias variáveis numéricas e quer explorar as relações entre elas, o lattice oferece o splom() (scatterplot matrix). # Gerando os dados simulados com DAP e Altura set.seed(123) dados &lt;- data.frame( DAP = c(rnorm(50, mean = 20, sd = 5), rnorm(50, mean = 25, sd = 6), rnorm(50, mean = 30, sd = 4)), Altura = c(rnorm(50, mean = 15, sd = 3), rnorm(50, mean = 18, sd = 2), rnorm(50, mean = 20, sd = 4)) ) # Calculando a biomassa dados$Biomassa &lt;- dados$DAP * dados$Altura * rnorm(150, mean = 0.1, sd = 0.01) # Gerando o scatterplot matrix (splom) library(lattice) splom(~ dados[c(&quot;DAP&quot;, &quot;Altura&quot;, &quot;Biomassa&quot;)], main = &quot;Matriz de Dispersão&quot;, col = &quot;darkblue&quot;, pch = 16) 2.4.8 Temporal condicional Se você possui dados temporais, como crescimento de árvores ao longo de anos ou medições sazonais, os gráficos de linha com painéis são muito úteis. # Dados simulados de crescimento anual set.seed(123) anos &lt;- 2000:2020 crescimento &lt;- expand.grid(Ano = anos, Especie = c(&quot;Espécie A&quot;, &quot;Espécie B&quot;, &quot;Espécie C&quot;)) crescimento$Altura &lt;- with(crescimento, ifelse(Especie == &quot;Espécie A&quot;, rnorm(length(Ano), mean = Ano - 1995, sd = 0.5), ifelse(Especie == &quot;Espécie B&quot;, rnorm(length(Ano), mean = Ano - 1993, sd = 0.7), rnorm(length(Ano), mean = Ano - 1990, sd = 0.6)))) # Gráfico de linha com painéis xyplot(Altura ~ Ano | Especie, data = crescimento, type = &quot;o&quot;, col = &quot;darkgreen&quot;, pch = 16, main = &quot;Crescimento por Espécie ao Longo dos Anos&quot;, xlab = &quot;Ano&quot;, ylab = &quot;Altura (m)&quot;) "],["dendrometria.html", "3 Dendrometria ", " 3 Dendrometria "],["diâmetros.html", "3.1 Diâmetros", " 3.1 Diâmetros 3.1.1 Histogramas de distribuição diamétrica Este tipo de abordagem é útil para se verificar o grau de aproximação da Normalidade dos dados pela “formato” das classes através da frequência de indivíduos por classe diamétrica. Os engenheiros florestais geralmente estabelecem classes diamétricas em intervalos fixos de 1,5 ou 2,0 cm para poderem comparar entre si as inúmeras parcelas; bem como para acompanhar a mudança de classe das árvores ao longo do tempo. 3.1.1.1 Criando dados para demonstração # Definir número de árvores por parcela n_arvores &lt;- 50 # Gerar dados de 3 parcelas com diâmetros distribuídos normalmente set.seed(123) # Para garantir reprodutibilidade parcela1 &lt;- rnorm(n_arvores, mean = 25, sd = 5) # Parcela 1 com média 25 cm e desvio padrão 5 cm parcela2 &lt;- rnorm(n_arvores, mean = 30, sd = 7) # Parcela 2 com média 30 cm e desvio padrão 7 cm parcela3 &lt;- rnorm(n_arvores, mean = 35, sd = 6) # Parcela 3 com média 35 cm e desvio padrão 6 cm # Criar um data frame com os dados das parcelas dados_inventario &lt;- data.frame( Parcela = rep(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), each = n_arvores), Diametro = c(parcela1, parcela2, parcela3) ) 3.1.1.2 Construindo os histogramas # Definir as classes diamétricas com intervalo de 2 cm intervalo &lt;- 2 min_diametro &lt;- floor(min(dados_inventario$Diametro)) # Valor mínimo de diâmetro arredondado para baixo max_diametro &lt;- ceiling(max(dados_inventario$Diametro)) # Valor máximo de diâmetro arredondado para cima intervalos &lt;- seq(min_diametro - intervalo, max_diametro + intervalo, by = intervalo) # Definir as classes com intervalo de 2 cm # Criar layout para os gráficos par(mfrow = c(1, 3)) # Define 3 gráficos em uma linha # Definir lista de parcelas parcelas &lt;- unique(dados_inventario$Parcela) # Loop para plotar histogramas de cada parcela for (parcela in parcelas) { # Selecionar os dados da parcela atual dados_parcela &lt;- dados_inventario[dados_inventario$Parcela == parcela, &quot;Diametro&quot;] # Plotar o histograma hist(dados_parcela, breaks = intervalos, main = paste(&quot;Histograma - parcela &quot;, parcela), xlab = &quot;Diâmetro (cm)&quot;, ylab = &quot;Frequência&quot;, ylim = c(0, 10), col = &quot;skyblue&quot;, border = &quot;black&quot;) } 3.1.1.3 Exercício Faça o mesmo gráfico com intervalos de 1,5 cm e mude a cor das barras para vermelho. Ver a Solução Solução do problema par(mfrow = c(1, 3)) # Define 3 gráficos em uma linha # Definir as classes diamétricas com intervalo de 2 cm intervalo &lt;- 1.5 intervalos &lt;- seq(min_diametro - intervalo, max_diametro + intervalo, by = intervalo) # Loop para plotar histogramas de cada parcela for (parcela in parcelas) { # Selecionar os dados da parcela atual dados_parcela &lt;- dados_inventario[dados_inventario$Parcela == parcela, &quot;Diametro&quot;] # Plotar o histograma hist(dados_parcela, breaks = intervalos, main = paste(&quot;Histograma - parcela &quot;, parcela), xlab = &quot;Diâmetro (cm)&quot;, ylab = &quot;Frequência&quot;, ylim = c(0, 10), col = &quot;red&quot;, border = &quot;black&quot;) } "],["inventário-florestal.html", "4 Inventário florestal ", " 4 Inventário florestal "],["fitossociologia-teoria.html", "4.1 Fitossociologia (Teoria)", " 4.1 Fitossociologia (Teoria) Os engenheiros florestais realizam estudos de fitossociologia para compreender a composição, a estrutura e as interações das comunidades vegetais em um determinado ecossistema. Esses estudos permitem identificar espécies dominantes, associadas e raras, além de avaliar a biodiversidade e as dinâmicas ecológicas do ambiente. Essas informações são essenciais para planejar o manejo sustentável, recuperar áreas degradadas e conservar ecossistemas naturais. Os engenheiros florestais realizam estudos de fitossociologia para determinar tipologias vegetais e fitofisionomias, aspectos fundamentais em processos como a Autorização para Exploração Vegetal (AUTEX) e os Programas de Recuperação Ambiental (PRA). 4.1.1 Estrutura horizontal 4.1.1.1 Densidade absoluta Refere-se ao número de indivíduos de uma espécie \\(i\\) (\\(n_i\\)) por unidade de área (\\(A\\)), expressando a abundância total da espécie na comunidade. \\[ DA_i = \\frac{n_i}{A} \\] 4.1.1.2 Densidade relativa É a proporção da densidade absoluta de uma espécie (\\(DA_i\\)) em relação à soma das densidades absolutas de todas as espécies, expressa em porcentagem. Indica a importância relativa da espécie em termos de abundância. \\[ DR_i = \\frac{DA_i}{\\sum_{i=1}^s (DA_i)} \\] 4.1.1.3 Dominância absoluta Calcula a área basal total (\\(G_i\\)) de todos os indivíduos de uma espécie por unidade de área (\\(A\\)). Mede o espaço físico ocupado por uma espécie no ambiente. \\[ DoA_i = \\frac{\\sum_{j=1}^{n_i} g_j}{A} = \\frac{G_i}{A} \\] 4.1.1.4 Dominância relativa Representa a proporção da dominância absoluta de uma espécie (\\(DoA_i\\)) em relação à dominância total (\\(G_T\\)) de todas as espécies, expressa em porcentagem. Indica a importância relativa em termos de área ocupada. \\[ DoR_i = \\frac{DoA_i}{\\sum_{i=1}^{S} (DoA_i)}*100=\\frac{G_i}{G_T}*100 \\] 4.1.1.5 Frequência Absoluta É a relação entre o número de unidades amostrais onde a espécie está presente (\\(U_i\\)) e o total de unidades amostrais (\\(U_T\\)), expressa em porcentagem. Mede a distribuição da espécie no espaço amostrado. \\[ FA_i = \\frac{U_i}{U_T}*100 \\] 4.1.1.6 Frequência Relativa Corresponde à frequência absoluta de uma espécie (\\(FA_i\\)) em relação à soma das frequências absolutas de todas as espécies, expressa em porcentagem. Avalia a importância espacial relativa da espécie. \\[ FR_i = \\frac{FA_i}{\\sum_{i=1}^{S}(FA_i)}*100 \\] 4.1.1.7 Valor de Cobertura É a soma da densidade relativa (\\(DR_i\\)), da dominância relativa (\\(DoR_i\\)) e, em alguns casos, da frequência relativa (\\(FR_i\\)), dependendo da metodologia. Reflete a contribuição total de uma espécie na comunidade. \\[ VC_i = DR_i + DoR_i + FR_i \\] 4.1.1.8 Porcentagem de Cobertura (Horizontal) É a média ponderada de densidade relativa, dominância relativa e, opcionalmente, frequência relativa. A interpretação pode variar entre o cálculo bidimensional (\\(DR + DoR\\)) ou tridimensional (\\(DR + DoR + FR\\)), dependendo do objetivo. \\[ PC_i = \\frac{DR_i + DoR_i + FR_i}{3} \\] 4.1.2 Diversidade 4.1.2.1 Índice de Shannom Quantifica a diversidade da comunidade, considerando tanto a abundância (\\(p_i\\)) quanto a equitabilidade das espécies. Valores maiores indicam maior diversidade e distribuição equitativa entre as espécies. \\[ H&#39; = -\\sum_{i=1}^S p_i \\ln(p_i) \\] 4.1.3 Agregação 4.1.3.1 Índice de Morisita Mede o padrão de distribuição espacial das espécies. Valores \\(I_\\delta &gt; 1\\) indicam agregação, \\(I_\\delta = 1\\) distribuição ao acaso, e \\(I_\\delta &lt; 1\\) distribuição uniforme. \\[ I_\\delta = \\frac{n \\sum_{i=1}^S n_i (n_i - 1)}{N (N - 1)} \\] 4.1.4 Estrutura vertical 4.1.4.1 Posição Sociológica Absoluta Representa a distribuição vertical de uma espécie na comunidade, considerando a contribuição proporcional das classes de altura. \\[ PSA_i = \\sum_{j=1}^{J}\\left(\\frac{N_j}{N} \\cdot N_{ij}\\right) \\] 4.1.4.2 Posição Sociológica Relativa É a proporção da posição sociológica absoluta de uma espécie (\\(PSA_i\\)) em relação à soma das posições sociológicas absolutas de todas as espécies, expressa em porcentagem. Indica a importância relativa da espécie na estrutura vertical. \\[ PSR_i = \\frac{PSA_i}{\\sum_{i=1}^{S} PSA_i} \\cdot 100 \\] 4.1.4.3 Valor de Importância Absoluta (Horizontal + Vertical) Combina os índices horizontais (densidade relativa, dominância relativa e frequência relativa) com a posição sociológica absoluta para refletir a contribuição global de uma espécie na comunidade. \\[ VI_a = DR_i + DoR_i + FR_i + PSA_i \\] 4.1.4.4 Valor de Importância Relativa (Horizontal + Vertical) É a média ponderada dos índices horizontais e verticais. Indica a importância relativa de uma espécie considerando a estrutura horizontal e vertical. \\[ VI_r = \\frac{DR_i + DoR_i + FR_i + PSA_i}{4} \\] 4.1.5 Regeneração Pode-se usar os mesmos índices anteriores de estrutura horizontal, vertical, etc. O resultado final será o Indicador de Regeneração Natural que poderá ser usado para calcular o Valor de Importância Ampliado: \\[ VIA_r = \\frac{DR_i + DoR_i + FR_i + PSA_i + RN_i}{5} \\] "],["fitossociologia-aplicação.html", "4.2 Fitossociologia (Aplicação)", " 4.2 Fitossociologia (Aplicação) De acordo com o estudo realizado por Verly et al. (2020), a caracterização florística defina para a Reserva Legal do IFMT foi de um fragmento Cerradão em estado de conservação adequada. De acordo com (Otávio Miranda Verly 2020), a caracterização florística… Dados exemplo: Baixar dados 4.2.1 Consistência dos dados Antes de qualquer análise, é fundamental verificar a consistência dos dados coletados. Isso envolve identificar e corrigir possíveis erros ou inconsistências, garantindo a qualidade e a confiabilidade das informações para as análises subsequentes. items_excluir &lt;- c(&quot;SP&quot;, &quot;Morta&quot;, &quot;PP&quot;, &quot;PS&quot;, &quot;Repetida&quot;, &quot;Repitida&quot;, &quot;Morfoespécie 7&quot;, &quot;Morfoespécie 8&quot;) BD_ &lt;- BD[!BD$`Nome Científico` %in% items_excluir, ] BD_$DAP &lt;- as.numeric(BD_$DAP) BD_$`H T` &lt;- as.numeric(BD_$`H T`) 4.2.2 Distribuição diamétrica geral A análise da distribuição dos diâmetros das árvores fornece insights sobre a estrutura etária e o desenvolvimento da floresta. Uma distribuição equilibrada indica uma regeneração contínua, enquanto a predominância de árvores em determinadas classes diamétricas pode sugerir distúrbios ou práticas de manejo específicas. intervalo &lt;- 5 max_d &lt;- ceiling(max(BD_$DAP, na.rm = TRUE)) intervalos &lt;- seq(0, max_d + intervalo, by = intervalo) hist(BD_$DAP, breaks = intervalos, main = NULL, xlab = &quot;Diâmetro (cm)&quot;, ylab = &quot;Frequência&quot;) 4.2.3 Distribuição por espécies (boxplots) Os boxplots permitem visualizar a variação dos diâmetros por espécie, destacando tendências e identificando outliers. Essa análise auxilia na compreensão do crescimento e do desenvolvimento de cada espécie, bem como na identificação de espécies que possam necessitar de atenção especial no manejo. 4.2.3.1 Boxplot dos DAPs require(ggplot2) especies &lt;- unique(BD_$`Nome Científico`) p &lt;- ggplot(BD_, aes(x = reorder(`Nome Científico`, DAP, median), y = DAP, fill = `Nome Científico`)) + geom_boxplot(outlier.shape = NA) + # Boxplot sem os outliers theme_minimal(base_size = 10) + theme( axis.text.x = element_text(angle = 45, hjust = 1, size = 6), legend.position = &quot;none&quot; # Remover legenda, se preferir ) + labs(title = &quot;Distribuição dos DAPs por Espécie&quot;, x = &quot;Espécies&quot;, y = &quot;DAP (cm)&quot;) print(p) 4.2.3.2 boxplot das alturas totais p &lt;- ggplot(BD_, aes(x = reorder(`Nome Científico`, `H T`, median), y = `H T`, fill = `Nome Científico`)) + geom_boxplot(outlier.shape = NA) + # Boxplot sem os outliers theme_minimal(base_size = 10) + theme( axis.text.x = element_text(angle = 45, hjust = 1, size = 6), legend.position = &quot;none&quot; # Remover legenda, se preferir ) + labs(title = &quot;Distribuição das HTs por Espécie&quot;, x = &quot;Espécies&quot;, y = &quot;HT (m)&quot;) print(p) 4.2.4 Parâmetros Fitossociológicos A aplicação prática dos parâmetros fitossociológicos, como densidade, dominância e frequência, fornece uma visão detalhada da composição e da estrutura da comunidade vegetal. Esses indicadores são essenciais para o planejamento de ações de manejo, conservação e recuperação de áreas florestais. 4.2.4.1 Estrutura horizontal EH &lt;- function(species, sample, d, A) { DT &lt;- data.table(species = species, sample = sample, d = d) DT &lt;- DT[, `:=`(gi = pi * d^2 / 40000)] Ui &lt;- unique(DT, by = c(&quot;species&quot;, &quot;sample&quot;))[, .(Ui = .N), by = &quot;species&quot;] ni &lt;- DT[, .(ni = .N, Gi = sum(gi)), by = &quot;species&quot;] ni &lt;- ni[Ui, on = &quot;species&quot;] ni[, DAi := ni / A][, DRi := (DAi / sum(DAi)) * 100] ni[, DoAi := Gi / A][, DoRi := (DoAi / sum(DoAi)) * 100] ni[, FAi := (Ui / length(unique(DT$sample))) * 100][, FRi := (FAi / sum(FAi)) * 100] num_cols &lt;- names(ni)[sapply(ni, is.numeric)] ni[, (num_cols) := lapply(.SD, round, 4), .SDcols = num_cols] setnames(ni, old = &quot;species&quot;, new = &quot;Espécies&quot;) return(ni) } EH_result &lt;- EH(BD_$`Nome Científico`, BD_$Parc, BD_$DAP, A = 0.8) Resultados: 4.2.4.2 Índice de Shannon (Diversidade) Na aplicação, o cálculo do índice de Shannon avalia a diversidade alfa da comunidade vegetal. Um valor alto reflete maior diversidade e distribuição equitativa entre as espécies no local estudado. shannon &lt;- function(species_counts) { pi &lt;- species_counts / sum(species_counts) -sum(pi * log(pi), na.rm = TRUE) } H &lt;- shannon(EH_result$ni) cat(&quot;Índice de Shannon:&quot;, H, &quot;\\n&quot;) ## Índice de Shannon: 3.16804 4.2.4.3 Índice de Morisita (Agregação) Mede o padrão de distribuição espacial das espécies. Valores \\(I_\\delta &gt; 1\\) indicam agregação. morisita &lt;- function(species_counts, parcelas) { # Agregar os indivíduos por parcela counts &lt;- tapply(species_counts, parcelas, sum) N &lt;- sum(counts) # Total de indivíduos em todas as parcelas n &lt;- length(counts) # Número de parcelas numerator &lt;- n * sum(counts * (counts - 1)) # Soma dos xi(xi - 1) por parcela denominator &lt;- N * (N - 1) # Total de combinações possíveis I_M &lt;- numerator / denominator return(I_M) } # Exemplo de aplicação: # Substituir species_counts e parcelas pelos dados reais species_counts &lt;- BD_$DAP[!is.na(BD_$DAP)] # DAP como proxy de presença/indivíduo parcelas &lt;- BD_$Parc # Número da parcela correspondente I_delta &lt;- morisita(species_counts, parcelas) cat(&quot;Índice de Morisita corrigido:&quot;, I_delta, &quot;\\n&quot;) ## Índice de Morisita corrigido: 1.022617 4.2.4.4 Estrutura vertical e classificação em estratos A inclusão da dimensão vertical nos parâmetros fitossociológicos agrega uma visão tridimensional da comunidade florestal, indo além da análise convencional baseada apenas na densidade e dominância (horizontal). BD_$`H T` &lt;- as.numeric(BD_$`H T`) meanH &lt;- mean(BD_$`H T`, na.rm = TRUE) sdH &lt;- sd(BD_$`H T`, na.rm = TRUE) # Calcular estrato BD_$estrato &lt;- case_when( BD_$`H T` &lt; (meanH - sdH) ~ &quot;Inferior&quot;, BD_$`H T` &gt;= (meanH - sdH) &amp; BD_$`H T` &lt;= (meanH + sdH) ~ &quot;Médio&quot;, BD_$`H T` &gt; (meanH + sdH) ~ &quot;Superior&quot; ) # Calcular PSAi e PSRi resultados &lt;- BD_ %&gt;% group_by(estrato) %&gt;% mutate( Nj = n(), # Total de indivíduos no estrato N = nrow(BD_), # Total de indivíduos na floresta Pj = Nj / N # Peso do estrato no total ) %&gt;% group_by(`Nome Científico`, estrato) %&gt;% summarise( Nji = n(), # Número de indivíduos da espécie no estrato Nj = first(Nj), # Total de indivíduos no estrato Pj = first(Pj), # Peso do estrato PSAi_partial = (Nji / Nj) * Pj, # Contribuição parcial para PSAi .groups = &quot;drop&quot; ) %&gt;% group_by(`Nome Científico`) %&gt;% summarise( PSAi = sum(PSAi_partial, na.rm = TRUE) # Soma das contribuições parciais para PSAi ) %&gt;% ungroup() %&gt;% mutate( PSRi = (PSAi / sum(PSAi, na.rm = TRUE)) * 100 # PSRi como porcentagem global ) # Fusão das tabelas com left_join EH_result &lt;- EH_result %&gt;% left_join(resultados, by = c(&quot;Espécies&quot; = &quot;Nome Científico&quot;)) # Adicionando o Valor de Importância Ampliado (VIA) required_cols &lt;- c(&quot;DAi&quot;, &quot;DoAi&quot;, &quot;FAi&quot;, &quot;PSAi&quot;, &quot;DRi&quot;, &quot;DoRi&quot;, &quot;FRi&quot;, &quot;PSRi&quot;) missing_cols &lt;- required_cols[!required_cols %in% names(EH_result)] if (length(missing_cols) &gt; 0) { stop(paste(&quot;Colunas ausentes em `EH_result`: &quot;, paste(missing_cols, collapse = &quot;, &quot;))) } EH_result &lt;- EH_result %&gt;% mutate( VIAa = (DAi + DoAi + FAi + PSAi) / 4, # Cálculo do VIA absoluto ) # Visualizar os resultados finais com arredondamento resultado_final &lt;- EH_result %&gt;% arrange(desc(VIAa)) %&gt;% mutate(across(where(is.numeric), round, 4)) Na aplicação prática, a utilização do VIA, que combina parâmetros horizontais e verticais com indicadores de regeneração, fornece uma visão holística da importância das espécies. Isso é fundamental para identificar não apenas as espécies dominantes atuais, mas também aquelas com maior potencial de contribuir para a sustentabilidade futura do ecossistema. Referências Otávio Miranda Verly, et al. 2020. “Caracterização florística e fitossociologia de um fragmento de Cerradão em Cáceres, Mato Grosso”. Pesquisa Florestal Brasileira 40: e201801742. "],["processo-em-conglomerados-teoria.html", "4.3 Processo em Conglomerados (Teoria)", " 4.3 Processo em Conglomerados (Teoria) 4.3.1 Média da população \\[\\bar{x} = \\frac{\\sum_{i=1}^n \\sum_{j=1}^m \\left( x_{ij} \\right)}{n \\cdot m}\\] 4.3.2 Média por subunidadae \\[\\bar{x}_i = \\frac{\\sum_{j=1}^m x_{ij}}{m}\\] 4.3.3 Variância total \\[S_x^2 = S_e^2 + S_d^2\\] 4.3.4 Variância dentro do conglomerado \\[S_d^2 = QM_{dentro} = \\frac{\\sum_{i=1}^n \\sum_{j=1}^m \\left( x_{ij} - \\bar{x}_i \\right)^2}{n \\cdot (m - 1)}\\] 4.3.5 Variância entre conglomerados \\[QM_{entre} = \\frac{\\sum_{i=1}^n m \\cdot \\left( \\bar{x}_i - \\bar{x} \\right)^2}{n - 1}\\] 4.3.6 Variância entre e dentro \\[S_e^2 = \\frac{QM_{entre} - QM_{dentro}}{m}\\] 4.3.7 Coeficiente de correlação intraconglomerado \\[\\rho = r = \\frac{S_e^2}{S_e^2 + S_d^2}\\] 4.3.8 Intensidade amostral requerida \\[n = \\frac{t^2 \\cdot S_x^2}{E^2 \\cdot M} \\cdot \\left[ 1 + r \\cdot (M - 1) \\right]\\] 4.3.9 Variância total \\[S_x^2 = S_e^2 + S_d^2\\] 4.3.10 Variância da média \\[S_{\\bar{x}}^2 = \\frac{N - n}{N} \\cdot \\frac{S_e^2}{n} + \\frac{M - m}{M} \\cdot \\frac{S_d^2}{n \\cdot m}\\] ou \\[S_{\\bar{x}}^2 = \\frac{S_x^2}{n \\cdot M} \\cdot \\left[ 1 + r \\cdot (M - 1) \\right]\\] 4.3.11 Erro padrão \\[S_{\\bar{x}} = \\sqrt{S_{\\bar{x}}^2}\\] 4.3.12 Erro da amostragem absoluto \\[S_{\\bar{x}} = \\sqrt{S_{\\bar{x}}^2}\\] 4.3.13 Erro de amostragem relativo \\[E_r = \\pm \\frac{t \\cdot S_{\\bar{x}}}{\\bar{x}} \\cdot 100\\] 4.3.14 Intervalo de confiança para Média \\[IC\\left[\\bar{x} - (E_a) \\leq \\bar{x} \\leq \\bar{x} + (E_a)\\right] = P\\] 4.3.15 Estimativa Total \\[\\hat{X} = N \\cdot M \\cdot \\bar{x}\\] 4.3.16 Intervalo de confiança total \\[IC\\left[\\hat{X} - N \\cdot M \\cdot (E_a) \\leq \\hat{X} \\leq \\hat{X} + N \\cdot M \\cdot (E_a)\\right] = P\\] "],["manejo-de-florestas-plantadas.html", "5 Manejo de Florestas Plantadas ", " 5 Manejo de Florestas Plantadas "],["altura-dominante.html", "5.1 Altura Dominante", " 5.1 Altura Dominante A altura dominante, que representa a média das alturas das árvores mais altas e/ou mais grossas de um determinado número de árvores por hectare, é menos influenciada por variações de densidade e competições locais entre árvores menores, tornando-a uma medida confiável da qualidade do sítio. Com ela, é possível estimar o potencial de crescimento da floresta, modelar curvas de crescimento e projetar a produção futura, auxiliando no planejamento sustentável e na tomada de decisões estratégicas no manejo florestal. Dados exemplo: Baixar dados A.Parc. Parc n DAP Ht Hdom 720 711 1 19.74 14.65 NA 720 711 2 NA NA NA 720 711 3 19.19 14.44 NA 720 711 4 17.83 13.89 NA 720 711 5 18.46 14.15 NA 720 711 6 20.05 14.78 NA 5.1.1 Calculando altura dominante por parcela (Assman) BD &lt;- read.csv2(&quot;data/DesafioCalcHdom.csv&quot;) colnames(BD)[1] = c(&quot;areaParc&quot;) BD &lt;- BD[, 1:5] BD &lt;- BD[order(BD$Parc, BD$DAP, decreasing = TRUE),] row.names(BD) &lt;- NULL Parc &lt;- unique(BD$Parc) Hdom_assman &lt;- unique(BD$Parc) j &lt;- 1 for (i in Parc) { a &lt;- ceiling(mean(BD[which(BD$Parc==i),1])*100/10000) H &lt;- BD[which(BD$Parc==i),5] Hdom_assman[j] &lt;- round(mean(H[1:a]), 2) j &lt;- j+1 } BD2 &lt;- as.data.frame(cbind(Parc, Hdom_assman)) BD &lt;- merge(BD, BD2) Resultado: Parc Hdom_assman 711 14.56 623 13.99 622 13.49 621 14.60 534 14.98 533 14.59 532 14.74 531 14.93 453 14.49 452 14.50 451 14.50 344 15.04 343 14.44 342 14.76 341 14.92 262 13.25 261 14.30 173 14.10 172 14.22 171 14.80 5.1.1.1 Exercício Faça o cálculo da altura dominante agora seguindo o conceito de Hart: 100 árvores mais altas por hectare. Tente usar o pipe para resolver o problema. Ver a Solução Solução do problema sem o pipe BD &lt;- read.csv2(&quot;data/DesafioCalcHdom.csv&quot;) colnames(BD)[1] = c(&quot;areaParc&quot;) BD &lt;- BD[, 1:5] BD &lt;- BD[order(BD$Parc, BD$Ht, decreasing = TRUE),] row.names(BD) &lt;- NULL Parc &lt;- unique(BD$Parc) Hdom_hart &lt;- unique(BD$Parc) j &lt;- 1 for (i in Parc) { a &lt;- ceiling(mean(BD[which(BD$Parc==i),1])*100/10000) H &lt;- BD[which(BD$Parc==i),5] Hdom_hart[j] &lt;- round(mean(H[1:a]), 2) j &lt;- j+1 } BD2 &lt;- as.data.frame(cbind(Parc, Hdom_hart)) BD &lt;- merge(BD, BD2) Resultado: Parc Hdom_hart 711 14.56 623 13.99 622 13.49 621 14.60 534 14.98 533 14.59 532 14.74 531 14.93 453 14.49 452 14.50 451 14.50 344 15.04 343 14.44 342 14.76 341 14.92 262 13.25 261 14.30 173 14.10 172 14.22 171 14.80 Solução com pipe library(dplyr) BD &lt;- BD %&gt;% arrange(Parc, desc(Ht)) # Garantir a ordem correta BD_Hart &lt;- BD %&gt;% group_by(Parc) %&gt;% mutate( num_top = ceiling(mean(areaParc) * 100 / 10000) ) %&gt;% slice(1:first(num_top)) %&gt;% summarise( Hdom_Hart2 = round(mean(Ht, na.rm = TRUE), 2) ) %&gt;% ungroup() BD_HDOM &lt;- merge(BD2, BD_Hart, by = &quot;Parc&quot;) Resultado: Parc Hdom_hart Hdom_Hart2 171 14.80 14.80 172 14.22 14.22 173 14.10 14.10 261 14.30 14.30 262 13.25 13.25 341 14.92 14.92 342 14.76 14.76 343 14.44 14.44 344 15.04 15.04 451 14.50 14.50 452 14.50 14.50 453 14.49 14.49 531 14.93 14.93 532 14.74 14.74 533 14.59 14.59 534 14.98 14.98 621 14.60 14.60 622 13.49 13.49 623 13.99 13.99 711 14.56 14.56 "],["referências.html", "Referências", " Referências Otávio Miranda Verly, et al. 2020. “Caracterização florística e fitossociologia de um fragmento de Cerradão em Cáceres, Mato Grosso”. Pesquisa Florestal Brasileira 40: e201801742. Wickham, Hadley, e contributors. 2021. Tidyverse Style Guide. RStudio, PBC. https://style.tidyverse.org/. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
