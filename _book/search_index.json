[["index.html", "Entre Florestas e Dados Sobre Por que este livro? Autor", " Entre Florestas e Dados Arthur Guilherme Schirmbeck Chaves Última atualização: 2024-11-17 Sobre “Entre Florestas e Dados” é um livro digital dinâmico (sempre atualizado online) que compartilha soluções práticas para análises de dados florestais utilizando a linguagem R. Por que este livro? Este livro foi criado para preencher uma lacuna na literatura sobre análise de dados aplicada especificamente ao setor florestal, com o intuito de capacitar profissionais a tomar decisões fundamentadas em dados de inventários, planejamento e monitoramento ambiental. Autor Olá! Meu nome é Arthur Guilherme Schirmbeck Chaves. Sou professor de Engenharia Florestal no IFMT. Como engenheiro florestal e analista de sistemas com sólida experiência em planejamento florestal, inventário, silvicultura e análise de dados, estou desenvolvendo este livro para compartilhar soluções práticas e orientadas por dados que aplico em minhas atividades profissionais e didáticas. Meu objetivo é capacitar profissionais e estudantes a compreender e implementar análises de dados na área florestal de forma eficaz, precisa e diretamente aplicável às demandas do setor. "],["introdução-ao-r.html", "1 Introdução ao R 1.1 Instalação do R 1.2 Instalação do RStudio 1.3 Fundamentos da linguagem 1.4 Gerenciamento de pacotes 1.5 Importação e exportação da dados 1.6 Pipe (%&gt;%) do dplyr 1.7 data.table 1.8 Manipulação de dados", " 1 Introdução ao R O livro R for Data Science é excelente1. Como mostrado em (Wickham e Grolemund 2016), o R facilita a análise de dados. 1.1 Instalação do R A instalação padrão do R é feita a partir do CRAN, uma rede de servidores espalhada pelo mundo que armazena versões idênticas e atualizadas de códigos e documentações para o R. Para instalar o R no Windows, siga os seguintes passos: Acesse o CRAN: https://www.r-project.org/ No menu à esquerda, encontre a opção Download e clique em CRAN. Escolha a opção de servidor (mirror) mais próxima de você. Clique em Download R for Windows. Clique na opção base. Na nova página, clique em Download R x.x.x for Windows, sendo x.x.x o número da versão que será baixada. Se você teve algum problema com o download, tente escolher outro servidor no passo 3. Feito o download, clique duas vezes no arquivo baixado e siga as instruções para instalação. 1.2 Instalação do RStudio 1.3 Fundamentos da linguagem 1.4 Gerenciamento de pacotes 1.5 Importação e exportação da dados 1.6 Pipe (%&gt;%) do dplyr 1.6.1 O que é o %&gt;%? O operador %&gt;% é chamado de pipe. Ele permite encadear funções de maneira a facilitar a leitura e compreensão do código. Ao invés de ficar atribuindo valores intermediários ou aninhando várias funções, você simplesmente passa o resultado de uma função como entrada para a próxima. 1.6.2 Exemplos de Uso Vamos usar o conjunto de dados mtcars para entender como o pipe facilita a manipulação de dados: Sem %&gt;% (Sem Pipe) Imagine que queremos fazer as seguintes operações no dataset mtcars: Filtrar apenas os carros que têm mais de 20 milhas por galão (mpg &gt; 20). Selecionar apenas as colunas mpg, cyl, e hp. Sem o operador %&gt;%, o código ficaria assim: library(dplyr) # Sem pipe filtered_data &lt;- filter(mtcars, mpg &gt; 20) selected_data &lt;- select(filtered_data, mpg, cyl, hp) Com %&gt;% (Com Pipe) Podemos simplificar isso usando o pipe: library(dplyr) # Usando pipe selected_data &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) mpg cyl hp Mazda RX4 21.0 6 110 Mazda RX4 Wag 21.0 6 110 Datsun 710 22.8 4 93 Hornet 4 Drive 21.4 6 110 Merc 240D 24.4 4 62 Merc 230 22.8 4 95 Note como o código com %&gt;% é mais legível e direto. Ele segue uma lógica sequencial que permite facilmente entender o que está sendo feito em cada etapa. 1.7 data.table 1.7.1 O que é o :=? O operador := é chamado de operador de atribuição por referência. Ele pertence ao pacote data.table e é usado para adicionar ou modificar colunas em um data.table. O := é mais eficiente do que usar &lt;- em um data.table, pois faz as modificações “por referência”, o que significa que não cria cópias desnecessárias dos dados, sendo muito mais rápido e eficiente em termos de memória. 1.7.2 Exemplos de Uso Vamos usar o pacote data.table para entender como o := funciona. Primeiro, vamos criar um data.table com alguns dados fictícios: library(data.table) # Criação de um data.table DT &lt;- data.table( id = 1:5, valor = c(10, 15, 20, 25, 30) ) Adicionando uma Nova Coluna com := Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor: DT[, valor_2 := valor * 2] print(DT) ## id valor valor_2 ## 1: 1 10 20 ## 2: 2 15 30 ## 3: 3 20 40 ## 4: 4 25 50 ## 5: 5 30 60 Modificando uma Coluna Existente com := Podemos também modificar uma coluna existente. Vamos modificar a coluna valor_2 para ser o triplo do valor da coluna valor: DT[, valor_2 := valor * 3] print(DT) ## id valor valor_2 ## 1: 1 10 30 ## 2: 2 15 45 ## 3: 3 20 60 ## 4: 4 25 75 ## 5: 5 30 90 1.8 Manipulação de dados References Wickham, Hadley, e Garrett Grolemund. 2016. R for Data Science. Sebastopol, CA: O’Reilly Media. https://r4ds.had.co.nz/. Wickham, H., &amp; Grolemund, G. (2016). R for Data Science. O’Reilly Media.↩︎ "],["dendrometria.html", "2 Dendrometria 2.1 Diâmetros 2.2 Alturas", " 2 Dendrometria 2.1 Diâmetros 2.1.1 Histogramas de distribuição diamétrica Este tipo de abordagem é útil para se verificar o grau de aproximação da Normalidade dos dados pela “formato” das classes através da frequência de indivíduos por classe diamétrica. Os engenheiros florestais geralmente estabelecem classes diamétricas em intervalos fixos de 1,5 ou 2,0 cm para poderem comparar entre si as inúmeras parcelas; bem como para acompanhar a mudança de classe das árvores ao longo do tempo. 2.1.1.1 Criando dados para demonstração # Definir número de árvores por parcela n_arvores &lt;- 50 # Gerar dados de 3 parcelas com diâmetros distribuídos normalmente set.seed(123) # Para garantir reprodutibilidade parcela1 &lt;- rnorm(n_arvores, mean = 25, sd = 5) # Parcela 1 com média 25 cm e desvio padrão 5 cm parcela2 &lt;- rnorm(n_arvores, mean = 30, sd = 7) # Parcela 2 com média 30 cm e desvio padrão 7 cm parcela3 &lt;- rnorm(n_arvores, mean = 35, sd = 6) # Parcela 3 com média 35 cm e desvio padrão 6 cm # Criar um data frame com os dados das parcelas dados_inventario &lt;- data.frame( Parcela = rep(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), each = n_arvores), Diametro = c(parcela1, parcela2, parcela3) ) 2.1.1.2 Construindo os histogramas # Definir as classes diamétricas com intervalo de 2 cm intervalo &lt;- 2 min_diametro &lt;- floor(min(dados_inventario$Diametro)) # Valor mínimo de diâmetro arredondado para baixo max_diametro &lt;- ceiling(max(dados_inventario$Diametro)) # Valor máximo de diâmetro arredondado para cima intervalos &lt;- seq(min_diametro - intervalo, max_diametro + intervalo, by = intervalo) # Definir as classes com intervalo de 2 cm # Criar layout para os gráficos par(mfrow = c(1, 3)) # Define 3 gráficos em uma linha # Definir lista de parcelas parcelas &lt;- unique(dados_inventario$Parcela) # Loop para plotar histogramas de cada parcela for (parcela in parcelas) { # Selecionar os dados da parcela atual dados_parcela &lt;- dados_inventario[dados_inventario$Parcela == parcela, &quot;Diametro&quot;] # Plotar o histograma hist(dados_parcela, breaks = intervalos, main = paste(&quot;Histograma - parcela &quot;, parcela), xlab = &quot;Diâmetro (cm)&quot;, ylab = &quot;Frequência&quot;, ylim = c(0, 10), col = &quot;skyblue&quot;, border = &quot;black&quot;) } 2.2 Alturas 2.2.1 Altura Dominante A altura dominante, que representa a média das alturas das árvores mais altas e/ou mais grossas de um determinado número de árvores por hectare, é menos influenciada por variações de densidade e competições locais entre árvores menores, tornando-a uma medida confiável da qualidade do sítio. Com ela, é possível estimar o potencial de crescimento da floresta, modelar curvas de crescimento e projetar a produção futura, auxiliando no planejamento sustentável e na tomada de decisões estratégicas no manejo florestal. Dados exemplo: Baixar dados A.Parc. Parc n DAP Ht Hdom 720 711 1 19.74 14.65 NA 720 711 2 NA NA NA 720 711 3 19.19 14.44 NA 720 711 4 17.83 13.89 NA 720 711 5 18.46 14.15 NA 720 711 6 20.05 14.78 NA 2.2.1.1 Calculando altura dominante por parcela (Assman) BD &lt;- read.csv2(&quot;data/DesafioCalcHdom.csv&quot;) colnames(BD)[1] = c(&quot;areaParc&quot;) BD &lt;- BD[, 1:5] BD &lt;- BD[order(BD$Parc, BD$Ht, decreasing = TRUE),] row.names(BD) &lt;- NULL Parc &lt;- unique(BD$Parc) Hdom &lt;- unique(BD$Parc) j &lt;- 1 for (i in Parc) { a &lt;- round(mean(BD[which(BD$Parc==i),1])*100/10000, 0) H &lt;- BD[which(BD$Parc==i),5] Hdom[j] &lt;- round(mean(H[1:a]), 2) j &lt;- j+1 } BD2 &lt;- as.data.frame(cbind(Parc, Hdom)) BD &lt;- merge(BD, BD2) rm(a, H, Hdom, i, j, Parc) Resultado: Parc Hdom 711 14.58 623 14.02 622 13.54 621 14.62 534 15.00 533 14.62 532 14.76 531 14.95 453 14.51 452 14.53 451 14.52 344 15.06 343 14.48 342 14.78 341 14.96 262 13.28 261 14.33 173 14.10 172 14.22 171 14.80 "],["inventário-florestal.html", "3 Inventário florestal 3.1 Levantamento Fitossociológico 3.2 Aplicação", " 3 Inventário florestal 3.1 Levantamento Fitossociológico 3.1.1 Estrutura horizontal 3.1.1.1 Densidade absoluta \\[ DA_i = \\frac{n_i}{A} \\] 3.1.1.2 Densidade relativa \\[ DR_i = \\frac{DA_i}{\\sum_{i=1}^s (DA_i)} \\] 3.1.1.3 Dominância absoluta \\[ DoA_i = \\frac{\\sum_{j=1}^{n_i} g_j}{A} = \\frac{G_i}{A} \\] 3.1.1.4 Dominância relativa \\[ DoR_i = \\frac{DoA_i}{\\sum_{i=1}^{S} (DoA_i)}*100=\\frac{G_i}{G_T}*100 \\] 3.1.1.5 Frequência Absoluta \\[ FA_i = \\frac{U_i}{U_T}*100 \\] 3.1.1.6 Frequência Relativa \\[ FR_i = \\frac{FA_i}{\\sum_{i=1}^{S}(FA_i)}*100 \\] 3.1.1.7 Valor de Cobertura \\[ VC_i = DR_i + DoR_i \\] 3.1.1.8 Porcentagem de Cobertura \\[ PC_i = \\frac{DR_i + DoR_i}{2} \\] 3.1.1.9 Valor de Cobertura \\[ VC_i = DR_i + DoR_i + FR_i \\] 3.1.1.10 Porcentagem de Cobertura (Horizontal) \\[ PC_i = \\frac{DR_i + DoR_i + FR_i}{3} \\] 3.1.2 Diversidade 3.1.2.1 Índice de Shannom \\[ H&#39; = -\\sum_{i=1}^S p_i \\ln(p_i) \\] 3.1.3 Agregação 3.1.3.1 Índice de Morisita \\[ I_\\delta = \\frac{n \\sum_{i=1}^S n_i (n_i - 1)}{N (N - 1)} \\] 3.1.4 Estrutura vertical 3.1.4.1 Posição Sociológica Absoluta \\[ PSA_i = \\sum_{j=1}^{J}\\left(\\frac{N_j}{N} \\cdot N_{ij}\\right) \\] 3.1.4.2 Posição Sociológica Relativa \\[ PSR_i = \\frac{PSA_i}{\\sum_{i=1}^{S} PSA_i} \\cdot 100 \\] 3.1.4.3 Valor de Importância Absoluta (Horizontal + Vertical) \\[ VI_a = DR_i + DoR_i + FR_i + PSA_i \\] 3.1.4.4 Valor de Importância Relativa (Horizontal + Vertical) \\[ VI_r = \\frac{DR_i + DoR_i + FR_i + PSA_i}{4} \\] 3.1.5 Regeneração Pode-se usar os mesmos índices anteriores de estrutura horizontal, vertical, etc. O resultado final será o Indicador de Regeneração Natural que poderá ser usado para calcular o Valor de Importância Ampliado: \\[ VIA_r = \\frac{DR_i + DoR_i + FR_i + PSA_i + RN_i}{5} \\] 3.2 Aplicação Dados exemplo: Baixar dados 3.2.1 Consistência dos dados items_excluir &lt;- c(&quot;SP&quot;, &quot;Morta&quot;, &quot;PP&quot;, &quot;PS&quot;, &quot;Repetida&quot;, &quot;Repitida&quot;, &quot;Morfoespécie 7&quot;, &quot;Morfoespécie 8&quot;) BD_ &lt;- BD[!BD$`Nome Científico` %in% items_excluir, ] BD_$DAP &lt;- as.numeric(BD_$DAP) BD_$`H T` &lt;- as.numeric(BD_$`H T`) 3.2.2 Distribuição diamétrica geral intervalo &lt;- 5 min_d &lt;- floor(min(BD_$DAP, na.rm = TRUE)) max_d &lt;- ceiling(max(BD_$DAP, na.rm = TRUE)) intervalos &lt;- seq(0, max_d + intervalo, by = intervalo) hist(BD_$DAP, breaks = intervalos, main = NULL, xlab = &quot;Diâmetro (cm)&quot;, ylab = &quot;Frequência&quot;) 3.2.3 Distribuição por espécies (boxplots) 3.2.3.1 Boxplot dos DAPs require(ggplot2) especies &lt;- unique(BD_$`Nome Científico`) p &lt;- ggplot(BD_, aes(x = reorder(`Nome Científico`, DAP, median), y = DAP, fill = `Nome Científico`)) + geom_boxplot(outlier.shape = NA) + # Boxplot sem os outliers theme_minimal(base_size = 10) + theme( axis.text.x = element_text(angle = 45, hjust = 1, size = 6), legend.position = &quot;none&quot; # Remover legenda, se preferir ) + labs(title = &quot;Distribuição dos DAPs por Espécie&quot;, x = &quot;Espécies&quot;, y = &quot;DAP (cm)&quot;) print(p) 3.2.3.2 boxplot das alturas totais p &lt;- ggplot(BD_, aes(x = reorder(`Nome Científico`, `H T`, median), y = `H T`, fill = `Nome Científico`)) + geom_boxplot(outlier.shape = NA) + # Boxplot sem os outliers theme_minimal(base_size = 10) + theme( axis.text.x = element_text(angle = 45, hjust = 1, size = 6), legend.position = &quot;none&quot; # Remover legenda, se preferir ) + labs(title = &quot;Distribuição das HTs por Espécie&quot;, x = &quot;Espécies&quot;, y = &quot;HT (m)&quot;) print(p) 3.2.4 Parâmetros Fitossociológicos 3.2.4.1 Estrutura horizontal EH &lt;- function(species, sample, d, A) { DT &lt;- data.table(species = species, sample = sample, d = d) DT &lt;- DT[, `:=`(gi = pi * d^2 / 40000)] Ui &lt;- unique(DT, by = c(&quot;species&quot;, &quot;sample&quot;))[, .(Ui = .N), by = &quot;species&quot;] ni &lt;- DT[, .(ni = .N, Gi = sum(gi)), by = &quot;species&quot;] ni &lt;- ni[Ui, on = &quot;species&quot;] ni[, DAi := ni / A][, DRi := (DAi / sum(DAi)) * 100] ni[, DoAi := Gi / A][, DoRi := (DoAi / sum(DoAi)) * 100] ni[, FAi := (Ui / length(unique(DT$sample))) * 100][, FRi := (FAi / sum(FAi)) * 100] num_cols &lt;- names(ni)[sapply(ni, is.numeric)] ni[, (num_cols) := lapply(.SD, round, 4), .SDcols = num_cols] setnames(ni, old = &quot;species&quot;, new = &quot;Espécies&quot;) return(ni) } EH_result &lt;- EH(BD_$`Nome Científico`, BD_$Parc, BD_$DAP, A = 0.8) Resultados: 3.2.4.2 Índice de Shannon (Diversidade) shannon &lt;- function(species_counts) { pi &lt;- species_counts / sum(species_counts) -sum(pi * log(pi), na.rm = TRUE) } H &lt;- shannon(EH_result$ni) cat(&quot;Índice de Shannon:&quot;, H, &quot;\\n&quot;) ## Índice de Shannon: 3.16804 3.2.4.3 Índice de Morisita (Agregação) morisita &lt;- function(species_counts, parcelas) { # Agregar os indivíduos por parcela counts &lt;- tapply(species_counts, parcelas, sum) N &lt;- sum(counts) # Total de indivíduos em todas as parcelas n &lt;- length(counts) # Número de parcelas numerator &lt;- n * sum(counts * (counts - 1)) # Soma dos xi(xi - 1) por parcela denominator &lt;- N * (N - 1) # Total de combinações possíveis I_M &lt;- numerator / denominator return(I_M) } # Exemplo de aplicação: # Substituir species_counts e parcelas pelos dados reais species_counts &lt;- BD_$DAP[!is.na(BD_$DAP)] # DAP como proxy de presença/indivíduo parcelas &lt;- BD_$Parc # Número da parcela correspondente I_delta &lt;- morisita(species_counts, parcelas) cat(&quot;Índice de Morisita corrigido:&quot;, I_delta, &quot;\\n&quot;) ## Índice de Morisita corrigido: 1.022617 3.2.4.4 Estrutura vertical e classificação em estratos BD_$`H T` &lt;- as.numeric(BD_$`H T`) meanH &lt;- mean(BD_$`H T`, na.rm = TRUE) sdH &lt;- sd(BD_$`H T`, na.rm = TRUE) # Calcular estrato BD_$estrato &lt;- case_when( BD_$`H T` &lt; (meanH - sdH) ~ &quot;Inferior&quot;, BD_$`H T` &gt;= (meanH - sdH) &amp; BD_$`H T` &lt;= (meanH + sdH) ~ &quot;Médio&quot;, BD_$`H T` &gt; (meanH + sdH) ~ &quot;Superior&quot; ) # Calcular PSAi e PSRi resultados &lt;- BD_ %&gt;% group_by(estrato) %&gt;% mutate( Nj = n(), # Total de indivíduos no estrato N = nrow(BD_), # Total de indivíduos na floresta Pj = Nj / N # Peso do estrato no total ) %&gt;% group_by(`Nome Científico`, estrato) %&gt;% summarise( Nji = n(), # Número de indivíduos da espécie no estrato Nj = first(Nj), # Total de indivíduos no estrato Pj = first(Pj), # Peso do estrato PSAi_partial = (Nji / Nj) * Pj, # Contribuição parcial para PSAi .groups = &quot;drop&quot; ) %&gt;% group_by(`Nome Científico`) %&gt;% summarise( PSAi = sum(PSAi_partial, na.rm = TRUE) # Soma das contribuições parciais para PSAi ) %&gt;% ungroup() %&gt;% mutate( PSRi = (PSAi / sum(PSAi, na.rm = TRUE)) * 100 # PSRi como porcentagem global ) # Fusão das tabelas com left_join EH_result &lt;- EH_result %&gt;% left_join(resultados, by = c(&quot;Espécies&quot; = &quot;Nome Científico&quot;)) # Adicionando o Valor de Importância Ampliado (VIA) required_cols &lt;- c(&quot;DAi&quot;, &quot;DoAi&quot;, &quot;FAi&quot;, &quot;PSAi&quot;, &quot;DRi&quot;, &quot;DoRi&quot;, &quot;FRi&quot;, &quot;PSRi&quot;) missing_cols &lt;- required_cols[!required_cols %in% names(EH_result)] if (length(missing_cols) &gt; 0) { stop(paste(&quot;Colunas ausentes em `EH_result`: &quot;, paste(missing_cols, collapse = &quot;, &quot;))) } EH_result &lt;- EH_result %&gt;% mutate( VIAa = (DAi + DoAi + FAi + PSAi) / 4, # Cálculo do VIA absoluto ) # Visualizar os resultados finais com arredondamento resultado_final &lt;- EH_result %&gt;% arrange(desc(VIAa)) %&gt;% mutate(across(where(is.numeric), round, 4)) Wickham, Hadley, e Garrett Grolemund. 2016. R for Data Science. Sebastopol, CA: O’Reilly Media. https://r4ds.had.co.nz/. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
