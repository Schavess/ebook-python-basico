[["index.html", "Entre Florestas e Dados Sobre", " Entre Florestas e Dados Arthur Guilherme Schirmbeck Chaves Última atualização: 2024-11-20 Sobre “Entre Florestas e Dados” é um livro digital dinâmico (sempre atualizado online) que compartilha soluções práticas para análises de dados florestais utilizando a linguagem R. "],["por-que-este-livro.html", "Por que este livro?", " Por que este livro? Este livro foi criado para preencher uma lacuna na literatura sobre análise de dados aplicada especificamente ao setor florestal, com o intuito de capacitar profissionais a tomar decisões fundamentadas em dados de inventários, planejamento e monitoramento ambiental. "],["autor.html", "Autor", " Autor Olá! Meu nome é Arthur Guilherme Schirmbeck Chaves. Sou professor de Engenharia Florestal no IFMT. Como engenheiro florestal e analista de sistemas com sólida experiência em planejamento florestal, inventário, silvicultura e análise de dados, estou desenvolvendo este livro para compartilhar soluções práticas e orientadas por dados para os engenheiros florestais empregarem em suas atividades profissionais e didáticas. "],["introdução-ao-r.html", "1 Introdução ao R", " 1 Introdução ao R O R é provavelmente a mais importante ferramenta para a análise de dados florestais. "],["instalação-do-r.html", "1.1 Instalação do R", " 1.1 Instalação do R A instalação padrão do R é feita a partir do CRAN, uma rede de servidores espalhada pelo mundo que armazena versões idênticas e atualizadas de códigos e documentações para o R. 1.1.1 Windows Para instalar o R no Windows, siga os seguintes passos: Acesse o CRAN: https://www.r-project.org/ No menu à esquerda, encontre a opção Download e clique em CRAN. Escolha a opção de servidor (mirror) mais próxima de você. Clique em Download R for Windows. Clique na opção base. Na nova página, clique em Download R x.x.x for Windows, sendo x.x.x o número da versão que será baixada. Se você teve algum problema com o download, tente escolher outro servidor no passo 3. Feito o download, clique duas vezes no arquivo baixado e siga as instruções para instalação. 1.1.2 macOS Abra o terminal: Command + Espaço “terminal” e Enter brew install --cask r 1.1.3 Linux Abra o terminal Linux: ctrl + alt + t sudo apt update sudo apt upgrade sudo apt install -y r-base "],["instalação-do-rstudio.html", "1.2 Instalação do RStudio", " 1.2 Instalação do RStudio Para instalar o RStudio, siga os passos atualizados abaixo: Acesse a página de downloads do RStudio: Visite https://posit.co/download/rstudio-desktop/#download. Verifique os requisitos do sistema: Certifique-se de que seu sistema operacional é compatível: Windows: Windows 10 ou superior (64 bits). macOS: macOS 11 (Big Sur) ou superior. Linux: Distribuições compatíveis incluem Debian 10, Ubuntu 18.04 LTS, Ubuntu 20.04 LTS, Ubuntu 22.04 LTS, Debian 9, RHEL/CentOS 7, RHEL 8 e OpenSUSE/SLES 15. Baixe o instalador adequado: Na seção “All Installers”, selecione o instalador correspondente ao seu sistema operacional. Instale o RStudio: 1.2.1 Windows Execute o arquivo .exe baixado e siga as instruções do assistente de instalação. 1.2.2 macOS Abra o arquivo .dmg baixado, arraste o ícone do RStudio para a pasta “Aplicativos” e, em seguida, ejete a imagem de disco. 1.2.3 Linux Baixe o pacote apropriado (.deb ou .rpm) e instale-o usando as ferramentas de gerenciamento de pacotes do seu sistema. Inicie o RStudio: Após a instalação, abra o RStudio para começar a utilizá-lo. Lembre-se de que o RStudio requer o R instalado previamente. Certifique-se de ter o R instalado antes de prosseguir com a instalação do RStudio. "],["sobre-o-r.html", "1.3 Sobre o R", " 1.3 Sobre o R 1.3.1 O que são algoritmos? Objetivo do Algoritmo: Plantar uma árvore. Entradas do Algoritmo: Uma muda de árvore. Local de plantio escolhido. Ferramentas para cavar (como uma pá). Água para regar a muda. Passos do Algoritmo: Selecionar o Local: Escolher um local adequado para plantar a muda, considerando a exposição solar, o tipo de solo e o espaço necessário para o crescimento da árvore. Cavar um Buraco: Usar a pá para cavar um buraco no local escolhido. O buraco deve ter profundidade e largura suficientes para acomodar as raízes da muda. Preparar a Muda: Remover a muda do recipiente em que veio, com cuidado para não danificar as raízes. Plantar a Muda: Colocar a muda no buraco, ajustando a profundidade para que a base do tronco fique no nível do solo. Preencher o buraco com terra, firmemente, mas sem compactar excessivamente. Regar a Muda: Regar a muda generosamente para umedecer o solo e ajudar a estabelecer as raízes. Cuidados Posteriores: Incluir instruções básicas de cuidados posteriores, como rega regular, aplicação de mulch para manter a umidade, e proteção contra ervas daninhas. Saída do Algoritmo: Uma árvore plantada e pronta para crescer no local escolhido. 1.3.2 O que é uma linguagem de programação? Uma linguagem de programação é uma forma padronizada de comunicar instruções a um computador. É como uma língua que permite aos programadores escreverem códigos que são convertidos em ações executáveis pelo computador, permitindo a criação de software, aplicativos, websites, e muito mais. Cada linguagem de programação tem sua própria sintaxe e regras, assim como as línguas humanas têm gramática e vocabulário. 1.3.3 R  R é uma linguagem de programação voltada para análise estatística e visualização de dados. Ela permite: - Manipulação de grandes volumes de dados  - Criação de gráficos avançados  - Modelagem estatística complexa  Com uma vasta comunidade e milhares de pacotes disponíveis, R é ideal tanto para iniciantes quanto para especialistas em ciência de dados. Alto Nível: R é uma linguagem de programação de alto nível projetada para abstrair detalhes técnicos e permitir que os usuários se concentrem na análise de dados e estatísticas. Ela automatiza tarefas como alocação de memória e manipulação de estruturas complexas, permitindo maior foco nos problemas analíticos e menos em detalhes de implementação. Foco em Análise de Dados: Diferentemente de linguagens de propósito geral, R é especialmente projetada para análise estatística, ciência de dados e visualização. É amplamente usada em áreas como bioestatística, econometria, aprendizado de máquina e pesquisa acadêmica, fornecendo ferramentas especializadas para cada etapa do fluxo de trabalho analítico. Visualizações Avançadas: R é reconhecida por sua capacidade de criar gráficos e visualizações de dados de alta qualidade, tanto para análises exploratórias quanto para apresentações profissionais. Com pacotes como ggplot2 e plotly, é possível produzir desde gráficos básicos até visualizações interativas complexas. Tipagem Dinâmica e Flexibilidade: R utiliza tipagem dinâmica, onde o tipo das variáveis é determinado em tempo de execução. Isso oferece flexibilidade para manipular diferentes tipos de dados, mas requer atenção para evitar inconsistências. Além disso, sua sintaxe foi projetada para facilitar operações vetoriais e manipulação de dados em larga escala, tornando-a eficiente em tarefas analíticas. "],["fundamentos-da-linguagem.html", "1.4 Fundamentos da linguagem", " 1.4 Fundamentos da linguagem 1.4.1 Boas práticas de codaR 1.4.1.1 O Básico Acesse no menu superior tools &gt; Global Options... &gt; code &gt; Display e defina os padrões de identação e estilização que deseja. E Salve. Agora basta selecionar o trecho de código e usar o atalho Ctrl + shift + A(Windows). 1.4.1.2 Avançado Para um estudo profundo verificar: O manual de referências de boas práticas (Wickham e contributors 2021) 1.4.2 ?Dúvidas ?mean # ou help(mean) 1.4.3 Tipos de dados Conhecer os tipos de dados utilizados pela linguagem é essencial para sua manipulação e análise. A seguir, estão os principais tipos de dados: Tipo Descrição Exemplo numeric Números, incluindo inteiros e reais 10, 10.5 integer Números inteiros as.integer(10) character Cadeias de caracteres (texto) \"Olá\" logical Valores booleanos TRUE, FALSE complex Números complexos 1+2i factor Variáveis categóricas factor(c(\"A\", \"B\", \"A\")) list Lista de elementos heterogêneos list(1, \"a\", TRUE) data.frame Tabela de dados estruturados data.frame(x = 1:3, y = 4:6) matrix Tabela de dados bidimensional matrix(1:6, nrow = 2) array Dados com mais de duas dimensões array(1:8, dim = c(2, 2, 2)) NULL Representa a ausência de valor NULL NA Valor ausente ou indefinido NA 1.4.4 Operadores Há inúmeras operações que podem ser realizadas com os dados dentro da lógica da programação. A seguir, estão os principais operadores: Categoria Operador Descrição Exemplo Aritmético + Adição x + y - Subtração x - y * Multiplicação x * y / Divisão x / y ^ Exponenciação x ^ y %% Módulo (resto da divisão) x %% y %/% Divisão inteira x %/% y Comparação == Igual a x == y != Diferente de x != y &gt; Maior que x &gt; y &lt; Menor que x &lt; y &gt;= Maior ou igual a x &gt;= y &lt;= Menor ou igual a x &lt;= y Lógico &amp; AND elemento por elemento x &amp; y | OR elemento por elemento x | y &amp;&amp; AND para o primeiro elemento x &amp;&amp; y | | OR para o primeiro elemento x | | y ! NOT lógico !x Atribuição &lt;- Atribui um valor x &lt;- y -&gt; Atribui um valor y -&gt; x = Atribui um valor x = y Pertencimento %in% Pertencimento (contém) x %in% y Bit a bit bitwAnd() AND bit a bit bitwAnd(x, y) bitwOr() OR bit a bit bitwOr(x, y) bitwXor() XOR bit a bit bitwXor(x, y) bitwNot() NOT bit a bit bitwNot(x) bitwShiftL() Deslocamento à esquerda bitwShiftL(x, n) bitwShiftR() Deslocamento à direita bitwShiftR(x, n) 1.4.5 Conversão de tipos Por se tratar de uma linguagem de tipagem dinâmica, é possível converter os tipos de dados: Função Descrição Exemplo Resultado as.numeric() Converte para tipo numérico as.numeric(\"10.5\") 10.5 (numeric) as.integer() Converte para inteiro as.integer(10.5) 10 (integer) as.character() Converte para texto (character) as.character(10) \"10\" (character) as.logical() Converte para lógico (booleano) as.logical(1) TRUE (logical) as.logical(0) FALSE (logical) as.complex() Converte para número complexo as.complex(10) 10+0i (complex) as.factor() Converte para fator (categorias) as.factor(c(\"A\", \"B\")) Factor com níveis as.list() Converte para lista as.list(c(1, 2, 3)) list(1, 2, 3) as.matrix() Converte para matriz as.matrix(c(1, 2, 3)) matrix (2D) as.data.frame() Converte para data frame as.data.frame(matrix(1:4, ncol=2)) data.frame as.Date() Converte para data (classe Date) as.Date(\"2024-11-18\") 2024-11-18 (Date) as.POSIXct() Converte para data/hora as.POSIXct(\"2024-11-18 10:00:00\") Data/hora (POSIXct) as.vector() Converte para vetor as.vector(matrix(1:4, nrow=2)) c(1, 2, 3, 4) as.array() Converte para array (multi-dimensional) as.array(1:8) array is.numeric() Testa se é numérico is.numeric(10.5) TRUE is.character() Testa se é texto is.character(\"text\") TRUE is.logical() Testa se é lógico is.logical(TRUE) TRUE is.factor() Testa se é fator is.factor(as.factor(\"A\")) TRUE 1.4.6 Estruturas de Controle A lógica da programação e a construção de algoritmos dependem das estruturas de controle: Estrutura Descrição Exemplo if Executa um bloco de código se a condição for verdadeira if (x &gt; 0) { print(\"Positivo\") } if-else Executa um bloco se a condição for verdadeira e outro se for falsa if (x &gt; 0) { print(\"Positivo\") } else { print(\"Negativo\") } ifelse Avaliação vetorizada para condicional result &lt;- ifelse(x &gt; 0, \"Positivo\", \"Negativo\") for Itera sobre elementos de um vetor ou lista for (i in 1:5) { print(i) } while Executa um bloco enquanto a condição for verdadeira while (x &lt; 5) { print(x); x &lt;- x + 1 } repeat Executa um bloco até encontrar um break repeat { if (x &gt; 5) break; print(x); x &lt;- x + 1 } break Interrompe a execução de um laço for (i in 1:5) { if (i == 3) break; print(i) } next Pula para a próxima iteração de um laço for (i in 1:5) { if (i == 3) next; print(i) } switch Seleciona uma opção com base em uma expressão switch(x, \"a\" = \"Opção A\", \"b\" = \"Opção B\") Funções anônimas Executa expressões diretamente em chamadas sapply(1:5, function(x) x^2) try Captura erros em blocos de código try({ log(\"a\") }) tryCatch Captura e lida com erros e mensagens tryCatch(log(\"a\"), error = function(e) print(\"Erro\")) Referências Wickham, Hadley, e contributors. 2021. Tidyverse Style Guide. RStudio, PBC. https://style.tidyverse.org/. "],["gerenciamento-de-pacotes.html", "1.5 Gerenciamento de Pacotes ", " 1.5 Gerenciamento de Pacotes  O R é uma linguagem poderosa, ampliada pelo uso de pacotes. Com pacotes, é possível adicionar novas funcionalidades e acessar ferramentas específicas para diversas tarefas, como visualização de dados, manipulação e modelagem estatística. 1.5.1 O que são pacotes? Pacotes no R são coleções de funções, conjuntos de dados e documentações. Eles estendem as funcionalidades do R base e são fundamentais para tarefas mais avançadas. Os pacotes podem ser obtidos do CRAN (repositório oficial), GitHub ou outras fontes. Pacotes populares incluem ggplot2 (gráficos), dplyr (manipulação de dados) e shiny (aplicações interativas). 1.5.2 Instalando pacotes Para instalar pacotes no R, utilize a função install.packages(). 1.5.2.1 Exemplo básico: # Instalando um pacote do CRAN install.packages(&quot;ggplot2&quot;) 1.5.2.2 Instalando múltiplos pacotes: install.packages(c(&quot;dplyr&quot;, &quot;tidyr&quot;, &quot;stringr&quot;)) 1.5.2.3 Instalando pacotes do GitHub: Pacotes disponíveis no GitHub requerem o pacote remotes ou devtools para instalação: # Instalando o pacote remotes install.packages(&quot;remotes&quot;) # Instalando um pacote do GitHub remotes::install_github(&quot;tidyverse/ggplot2&quot;) 1.5.3 Carregando pacotes Depois de instalados, os pacotes precisam ser carregados para uso. Isso é feito com a função library(). 1.5.3.1 Exemplo: # Carregando o pacote ggplot2 library(ggplot2) Se você não quiser carregar o pacote inteiro, pode usar o operador :: para chamar uma função específica: # Usando a função ggplot() sem carregar o pacote ggplot2::ggplot(data = mtcars, aes(x = mpg, y = hp)) 1.5.4 Atualizando pacotes Pacotes instalados podem ser atualizados para suas versões mais recentes. 1.5.4.1 Atualizando todos os pacotes: update.packages() 1.5.4.2 Atualizando pacotes específicos: Reinstale o pacote desejado: install.packages(&quot;dplyr&quot;) 1.5.5 Removendo pacotes Se um pacote não for mais necessário, você pode removê-lo com a função remove.packages(). 1.5.5.1 Exemplo: remove.packages(&quot;stringr&quot;) 1.5.6 Verificando pacotes instalados Você pode listar todos os pacotes instalados ou verificar se um pacote específico está presente. 1.5.6.1 Listando todos os pacotes: installed.packages() 1.5.6.2 Verificando se um pacote está instalado: &quot;ggplot2&quot; %in% rownames(installed.packages()) 1.5.7 Repositórios O R utiliza o CRAN como repositório padrão para instalação de pacotes. No entanto, você pode configurar o repositório manualmente, por exemplo, escolhendo um mirror mais rápido: # Configurando um repositório brasileiro options(repos = c(CRAN = &quot;https://cran.rstudio.com/&quot;)) 1.5.8 Ferramentas avançadas para gerenciamento Para projetos complexos, você pode usar ferramentas para gerenciar versões de pacotes e ambientes: renv: Cria ambientes isolados para projetos, garantindo que as dependências permaneçam consistentes: install.packages(&quot;renv&quot;) renv::init() packrat: Alternativa mais antiga ao renv, também para isolamento de dependências. conda: Se você utiliza Python junto com R, o conda permite gerenciar pacotes R em ambientes híbridos. "],["importação-e-exportação-de-dados.html", "1.6 Importação e Exportação de Dados ", " 1.6 Importação e Exportação de Dados  O R oferece diversas ferramentas para importar e exportar dados em diferentes formatos, permitindo que você trabalhe com arquivos como CSV, Excel, bancos de dados, arquivos de texto e muito mais. 1.6.1 Importando dados 1.6.1.1 1. Arquivos CSV O formato CSV é amplamente utilizado e facilmente manipulável no R com a função read.csv() ou a função mais moderna readr::read_csv(). # Usando a função base dados &lt;- read.csv(&quot;caminho/para/seu/arquivo.csv&quot;) # Usando o pacote readr (do Tidyverse) dados &lt;- readr::read_csv(&quot;caminho/para/seu/arquivo.csv&quot;) 1.6.1.2 2. Arquivos Excel Para importar dados de planilhas Excel, você pode usar pacotes como readxl ou openxlsx. # Instale o pacote readxl, se necessário install.packages(&quot;readxl&quot;) # Lendo uma planilha Excel library(readxl) dados &lt;- read_excel(&quot;caminho/para/seu/arquivo.xlsx&quot;, sheet = 1) 1.6.1.3 3. Arquivos de texto Para arquivos de texto delimitados (como TSV), use read.delim() ou readr::read_tsv(). # Arquivo delimitado por tabulação dados &lt;- read.delim(&quot;caminho/para/seu/arquivo.txt&quot;) # Com readr dados &lt;- readr::read_tsv(&quot;caminho/para/seu/arquivo.txt&quot;) 1.6.1.4 4. Bancos de Dados Para se conectar a bancos de dados, use pacotes como DBI e RSQLite. # Exemplo com SQLite install.packages(&quot;DBI&quot;) install.packages(&quot;RSQLite&quot;) library(DBI) con &lt;- dbConnect(RSQLite::SQLite(), &quot;caminho/para/seu/banco.sqlite&quot;) dados &lt;- dbReadTable(con, &quot;nome_da_tabela&quot;) dbDisconnect(con) 1.6.1.5 5. Outros formatos populares JSON: Use o pacote jsonlite. XML: Use o pacote xml2. Arquivos SPSS, Stata e SAS: Use o pacote haven. # Exemplo de JSON install.packages(&quot;jsonlite&quot;) dados &lt;- jsonlite::fromJSON(&quot;caminho/para/seu/arquivo.json&quot;) 1.6.2 Exportando dados 1.6.2.1 1. Exportando para CSV A função write.csv() é usada para salvar dados em formato CSV. # Salvando um data frame como CSV write.csv(dados, &quot;caminho/para/saida.csv&quot;, row.names = FALSE) 1.6.2.2 2. Exportando para Excel Para salvar dados em Excel, use o pacote openxlsx. # Instale o pacote openxlsx, se necessário install.packages(&quot;openxlsx&quot;) # Escrevendo dados em uma planilha Excel library(openxlsx) write.xlsx(dados, &quot;caminho/para/saida.xlsx&quot;) 1.6.2.3 3. Exportando para outros formatos O R permite salvar dados em diversos formatos com as funções correspondentes: - Texto (write.table()) - JSON (jsonlite::toJSON()) - Bancos de dados (dbWriteTable()). Exemplo com JSON: jsonlite::toJSON(dados, pretty = TRUE, file = &quot;caminho/para/saida.json&quot;) 1.6.3 Dicas e boas práticas Sempre verifique os tipos de dados importados com str() ou glimpse(). Para grandes volumes de dados, considere pacotes otimizados como data.table ou vroom. Configure o diretório de trabalho corretamente para evitar erros de caminho: setwd(&quot;caminho/para/seu/diretorio&quot;) "],["funções-da-família-apply-no-r.html", "1.7 Funções da família apply() no R", " 1.7 Funções da família apply() no R As funções da família apply() são usadas para realizar operações repetitivas em vetores, listas, matrizes e data frames de forma eficiente e vetorizada, substituindo muitos loops explícitos (for). 1.7.1 1. apply() Aplica uma função ao longo de uma margem de uma matriz ou array (linhas ou colunas). Uso: Para matrizes e arrays. Sintaxe: apply(X, MARGIN, FUN, ...) X: Matriz ou array. MARGIN: Margem a operar: 1 para linhas. 2 para colunas. FUN: Função a ser aplicada. Exemplo: # Soma das colunas de uma matriz mat &lt;- matrix(1:9, nrow = 3) apply(mat, 2, sum) # Resultado: [1] 12 15 18 # Média das linhas apply(mat, 1, mean) # Resultado: [1] 2 5 8 1.7.2 2. lapply() Aplica uma função a cada elemento de uma lista ou vetor e retorna uma lista como resultado. Uso: Para listas e vetores. Sintaxe: lapply(X, FUN, ...) Exemplo: # Quadrado de cada elemento de um vetor vec &lt;- 1:5 lapply(vec, function(x) x^2) # Resultado: [[1]] 1, [[2]] 4, [[3]] 9, [[4]] 16, [[5]] 25 # Aplicação em uma lista lst &lt;- list(a = 1:3, b = 4:6) lapply(lst, sum) # Resultado: $a 6, $b 15 1.7.3 3. sapply() Uma versão simplificada de lapply() que retorna um vetor ou matriz (se possível) em vez de uma lista. Uso: Para listas e vetores. Sintaxe: sapply(X, FUN, ...) Exemplo: # Quadrado de cada elemento vec &lt;- 1:5 sapply(vec, function(x) x^2) # Resultado: [1] 1 4 9 16 25 # Soma dos elementos em uma lista lst &lt;- list(a = 1:3, b = 4:6) sapply(lst, sum) # Resultado: [1] 6 15 1.7.4 4. vapply() Semelhante a sapply(), mas requer que você especifique o tipo de retorno esperado (mais seguro). Uso: Para listas e vetores. Sintaxe: vapply(X, FUN, FUN.VALUE, ...) FUN.VALUE: Define o tipo e formato esperado do retorno. Exemplo: # Soma dos elementos em uma lista com tipo esperado (numeric) lst &lt;- list(a = 1:3, b = 4:6) vapply(lst, sum, numeric(1)) # Resultado: [1] 6 15 1.7.5 5. mapply() Aplica uma função a múltiplos argumentos/vetores simultaneamente (como um map em Python). Uso: Para múltiplos vetores ou listas. Sintaxe: mapply(FUN, ..., MoreArgs = NULL) Exemplo: # Soma de dois vetores vec1 &lt;- 1:5 vec2 &lt;- 6:10 mapply(sum, vec1, vec2) # Resultado: [1] 7 9 11 13 15 # Repetição customizada mapply(rep, 1:3, 3:1) # Resultado: [[1]] 1, [[2]] 2 2, [[3]] 3 3 3 1.7.6 6. tapply() Aplica uma função a subconjuntos de um vetor, definidos por um fator ou grupos. Uso: Para agrupamento. Sintaxe: tapply(X, INDEX, FUN, ...) X: Vetor numérico. INDEX: Fator ou lista de fatores para agrupar. Exemplo: # Média por grupo vec &lt;- c(1, 2, 3, 4, 5, 6) grp &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;)) tapply(vec, grp, mean) # Resultado: $A 1.5, $B 3.5, $C 5.5 1.7.7 7. by() Semelhante a tapply(), mas retorna resultados organizados por subgrupos e funciona com data frames. Uso: Para data frames. Sintaxe: by(data, INDICES, FUN, ...) Exemplo: # Soma dos valores por grupo em um data frame df &lt;- data.frame(value = 1:6, group = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;)) by(df$value, df$group, sum) # Resultado: # A: 3 # B: 7 # C: 11 Conclusão As funções da família apply() tornam o R extremamente poderoso e eficiente para manipulação de dados. Use: - apply() para matrizes/arrays. - lapply() e sapply() para listas/vetores. - mapply() para múltiplos vetores. - tapply() e by() para agrupamentos. "],["pipe-do-dplyr.html", "1.8 Pipe (%&gt;%) do dplyr", " 1.8 Pipe (%&gt;%) do dplyr 1.8.1 O que é o %&gt;%? O operador %&gt;% é chamado de pipe. Ele permite encadear funções de maneira a facilitar a leitura e compreensão do código. Ao invés de ficar atribuindo valores intermediários ou aninhando várias funções, você simplesmente passa o resultado de uma função como entrada para a próxima. 1.8.2 Exemplos de Uso Vamos usar o conjunto de dados mtcars para entender como o pipe facilita a manipulação de dados: Sem %&gt;% (Sem Pipe) Imagine que queremos fazer as seguintes operações no dataset mtcars: Filtrar apenas os carros que têm mais de 20 milhas por galão (mpg &gt; 20). Selecionar apenas as colunas mpg, cyl, e hp. Sem o operador %&gt;%, o código ficaria assim: library(dplyr) # Sem pipe filtered_data &lt;- filter(mtcars, mpg &gt; 20) selected_data &lt;- select(filtered_data, mpg, cyl, hp) Com %&gt;% (Com Pipe) Podemos simplificar isso usando o pipe: library(dplyr) # Usando pipe selected_data &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) mpg cyl hp Mazda RX4 21.0 6 110 Mazda RX4 Wag 21.0 6 110 Datsun 710 22.8 4 93 Hornet 4 Drive 21.4 6 110 Merc 240D 24.4 4 62 Merc 230 22.8 4 95 Note como o código com %&gt;% é mais legível e direto. Ele segue uma lógica sequencial que permite facilmente entender o que está sendo feito em cada etapa. "],["data.html", "1.9 data.table", " 1.9 data.table 1.9.1 O que é o :=? O operador := é chamado de operador de atribuição por referência. Ele pertence ao pacote data.table e é usado para adicionar ou modificar colunas em um data.table. O := é mais eficiente do que usar &lt;- em um data.table, pois faz as modificações “por referência”, o que significa que não cria cópias desnecessárias dos dados, sendo muito mais rápido e eficiente em termos de memória. 1.9.2 Exemplos de Uso Vamos usar o pacote data.table para entender como o := funciona. Primeiro, vamos criar um data.table com alguns dados fictícios: library(data.table) # Criação de um data.table DT &lt;- data.table( id = 1:5, valor = c(10, 15, 20, 25, 30) ) Adicionando uma Nova Coluna com := Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor: DT[, valor_2 := valor * 2] print(DT) ## id valor valor_2 ## 1: 1 10 20 ## 2: 2 15 30 ## 3: 3 20 40 ## 4: 4 25 50 ## 5: 5 30 60 Modificando uma Coluna Existente com := Podemos também modificar uma coluna existente. Vamos modificar a coluna valor_2 para ser o triplo do valor da coluna valor: DT[, valor_2 := valor * 3] print(DT) ## id valor valor_2 ## 1: 1 10 30 ## 2: 2 15 45 ## 3: 3 20 60 ## 4: 4 25 75 ## 5: 5 30 90 "],["inventário-florestal.html", "2 Inventário florestal ", " 2 Inventário florestal "],["fitossociologia-teoria.html", "2.1 Fitossociologia (Teoria)", " 2.1 Fitossociologia (Teoria) Os engenheiros florestais realizam estudos de fitossociologia para compreender a composição, a estrutura e as interações das comunidades vegetais em um determinado ecossistema. Esses estudos permitem identificar espécies dominantes, associadas e raras, além de avaliar a biodiversidade e as dinâmicas ecológicas do ambiente. Essas informações são essenciais para planejar o manejo sustentável, recuperar áreas degradadas e conservar ecossistemas naturais. Os engenheiros florestais realizam estudos de fitossociologia para determinar tipologias vegetais e fitofisionomias, aspectos fundamentais em processos como a Autorização para Exploração Vegetal (AUTEX) e os Programas de Recuperação Ambiental (PRA). 2.1.1 Estrutura horizontal 2.1.1.1 Densidade absoluta Refere-se ao número de indivíduos de uma espécie \\(i\\) (\\(n_i\\)) por unidade de área (\\(A\\)), expressando a abundância total da espécie na comunidade. \\[ DA_i = \\frac{n_i}{A} \\] 2.1.1.2 Densidade relativa É a proporção da densidade absoluta de uma espécie (\\(DA_i\\)) em relação à soma das densidades absolutas de todas as espécies, expressa em porcentagem. Indica a importância relativa da espécie em termos de abundância. \\[ DR_i = \\frac{DA_i}{\\sum_{i=1}^s (DA_i)} \\] 2.1.1.3 Dominância absoluta Calcula a área basal total (\\(G_i\\)) de todos os indivíduos de uma espécie por unidade de área (\\(A\\)). Mede o espaço físico ocupado por uma espécie no ambiente. \\[ DoA_i = \\frac{\\sum_{j=1}^{n_i} g_j}{A} = \\frac{G_i}{A} \\] 2.1.1.4 Dominância relativa Representa a proporção da dominância absoluta de uma espécie (\\(DoA_i\\)) em relação à dominância total (\\(G_T\\)) de todas as espécies, expressa em porcentagem. Indica a importância relativa em termos de área ocupada. \\[ DoR_i = \\frac{DoA_i}{\\sum_{i=1}^{S} (DoA_i)}*100=\\frac{G_i}{G_T}*100 \\] 2.1.1.5 Frequência Absoluta É a relação entre o número de unidades amostrais onde a espécie está presente (\\(U_i\\)) e o total de unidades amostrais (\\(U_T\\)), expressa em porcentagem. Mede a distribuição da espécie no espaço amostrado. \\[ FA_i = \\frac{U_i}{U_T}*100 \\] 2.1.1.6 Frequência Relativa Corresponde à frequência absoluta de uma espécie (\\(FA_i\\)) em relação à soma das frequências absolutas de todas as espécies, expressa em porcentagem. Avalia a importância espacial relativa da espécie. \\[ FR_i = \\frac{FA_i}{\\sum_{i=1}^{S}(FA_i)}*100 \\] 2.1.1.7 Valor de Cobertura É a soma da densidade relativa (\\(DR_i\\)), da dominância relativa (\\(DoR_i\\)) e, em alguns casos, da frequência relativa (\\(FR_i\\)), dependendo da metodologia. Reflete a contribuição total de uma espécie na comunidade. \\[ VC_i = DR_i + DoR_i + FR_i \\] 2.1.1.8 Porcentagem de Cobertura (Horizontal) É a média ponderada de densidade relativa, dominância relativa e, opcionalmente, frequência relativa. A interpretação pode variar entre o cálculo bidimensional (\\(DR + DoR\\)) ou tridimensional (\\(DR + DoR + FR\\)), dependendo do objetivo. \\[ PC_i = \\frac{DR_i + DoR_i + FR_i}{3} \\] 2.1.2 Diversidade 2.1.2.1 Índice de Shannom Quantifica a diversidade da comunidade, considerando tanto a abundância (\\(p_i\\)) quanto a equitabilidade das espécies. Valores maiores indicam maior diversidade e distribuição equitativa entre as espécies. \\[ H&#39; = -\\sum_{i=1}^S p_i \\ln(p_i) \\] 2.1.3 Agregação 2.1.3.1 Índice de Morisita Mede o padrão de distribuição espacial das espécies. Valores \\(I_\\delta &gt; 1\\) indicam agregação, \\(I_\\delta = 1\\) distribuição ao acaso, e \\(I_\\delta &lt; 1\\) distribuição uniforme. \\[ I_\\delta = \\frac{n \\sum_{i=1}^S n_i (n_i - 1)}{N (N - 1)} \\] 2.1.4 Estrutura vertical 2.1.4.1 Posição Sociológica Absoluta Representa a distribuição vertical de uma espécie na comunidade, considerando a contribuição proporcional das classes de altura. \\[ PSA_i = \\sum_{j=1}^{J}\\left(\\frac{N_j}{N} \\cdot N_{ij}\\right) \\] 2.1.4.2 Posição Sociológica Relativa É a proporção da posição sociológica absoluta de uma espécie (\\(PSA_i\\)) em relação à soma das posições sociológicas absolutas de todas as espécies, expressa em porcentagem. Indica a importância relativa da espécie na estrutura vertical. \\[ PSR_i = \\frac{PSA_i}{\\sum_{i=1}^{S} PSA_i} \\cdot 100 \\] 2.1.4.3 Valor de Importância Absoluta (Horizontal + Vertical) Combina os índices horizontais (densidade relativa, dominância relativa e frequência relativa) com a posição sociológica absoluta para refletir a contribuição global de uma espécie na comunidade. \\[ VI_a = DR_i + DoR_i + FR_i + PSA_i \\] 2.1.4.4 Valor de Importância Relativa (Horizontal + Vertical) É a média ponderada dos índices horizontais e verticais. Indica a importância relativa de uma espécie considerando a estrutura horizontal e vertical. \\[ VI_r = \\frac{DR_i + DoR_i + FR_i + PSA_i}{4} \\] 2.1.5 Regeneração Pode-se usar os mesmos índices anteriores de estrutura horizontal, vertical, etc. O resultado final será o Indicador de Regeneração Natural que poderá ser usado para calcular o Valor de Importância Ampliado: \\[ VIA_r = \\frac{DR_i + DoR_i + FR_i + PSA_i + RN_i}{5} \\] "],["fitossociologia-aplicação.html", "2.2 Fitossociologia (Aplicação)", " 2.2 Fitossociologia (Aplicação) De acordo com o estudo realizado por Verly et al. (2020), a caracterização florística defina para a Reserva Legal do IFMT foi de um fragmento Cerradão em estado de conservação adequada. De acordo com (Otávio Miranda Verly 2020), a caracterização florística… Dados exemplo: Baixar dados 2.2.1 Consistência dos dados Antes de qualquer análise, é fundamental verificar a consistência dos dados coletados. Isso envolve identificar e corrigir possíveis erros ou inconsistências, garantindo a qualidade e a confiabilidade das informações para as análises subsequentes. items_excluir &lt;- c(&quot;SP&quot;, &quot;Morta&quot;, &quot;PP&quot;, &quot;PS&quot;, &quot;Repetida&quot;, &quot;Repitida&quot;, &quot;Morfoespécie 7&quot;, &quot;Morfoespécie 8&quot;) BD_ &lt;- BD[!BD$`Nome Científico` %in% items_excluir, ] BD_$DAP &lt;- as.numeric(BD_$DAP) BD_$`H T` &lt;- as.numeric(BD_$`H T`) 2.2.2 Distribuição diamétrica geral A análise da distribuição dos diâmetros das árvores fornece insights sobre a estrutura etária e o desenvolvimento da floresta. Uma distribuição equilibrada indica uma regeneração contínua, enquanto a predominância de árvores em determinadas classes diamétricas pode sugerir distúrbios ou práticas de manejo específicas. intervalo &lt;- 5 max_d &lt;- ceiling(max(BD_$DAP, na.rm = TRUE)) intervalos &lt;- seq(0, max_d + intervalo, by = intervalo) hist(BD_$DAP, breaks = intervalos, main = NULL, xlab = &quot;Diâmetro (cm)&quot;, ylab = &quot;Frequência&quot;) 2.2.3 Distribuição por espécies (boxplots) Os boxplots permitem visualizar a variação dos diâmetros por espécie, destacando tendências e identificando outliers. Essa análise auxilia na compreensão do crescimento e do desenvolvimento de cada espécie, bem como na identificação de espécies que possam necessitar de atenção especial no manejo. 2.2.3.1 Boxplot dos DAPs require(ggplot2) especies &lt;- unique(BD_$`Nome Científico`) p &lt;- ggplot(BD_, aes(x = reorder(`Nome Científico`, DAP, median), y = DAP, fill = `Nome Científico`)) + geom_boxplot(outlier.shape = NA) + # Boxplot sem os outliers theme_minimal(base_size = 10) + theme( axis.text.x = element_text(angle = 45, hjust = 1, size = 6), legend.position = &quot;none&quot; # Remover legenda, se preferir ) + labs(title = &quot;Distribuição dos DAPs por Espécie&quot;, x = &quot;Espécies&quot;, y = &quot;DAP (cm)&quot;) print(p) 2.2.3.2 boxplot das alturas totais p &lt;- ggplot(BD_, aes(x = reorder(`Nome Científico`, `H T`, median), y = `H T`, fill = `Nome Científico`)) + geom_boxplot(outlier.shape = NA) + # Boxplot sem os outliers theme_minimal(base_size = 10) + theme( axis.text.x = element_text(angle = 45, hjust = 1, size = 6), legend.position = &quot;none&quot; # Remover legenda, se preferir ) + labs(title = &quot;Distribuição das HTs por Espécie&quot;, x = &quot;Espécies&quot;, y = &quot;HT (m)&quot;) print(p) 2.2.4 Parâmetros Fitossociológicos A aplicação prática dos parâmetros fitossociológicos, como densidade, dominância e frequência, fornece uma visão detalhada da composição e da estrutura da comunidade vegetal. Esses indicadores são essenciais para o planejamento de ações de manejo, conservação e recuperação de áreas florestais. 2.2.4.1 Estrutura horizontal EH &lt;- function(species, sample, d, A) { DT &lt;- data.table(species = species, sample = sample, d = d) DT &lt;- DT[, `:=`(gi = pi * d^2 / 40000)] Ui &lt;- unique(DT, by = c(&quot;species&quot;, &quot;sample&quot;))[, .(Ui = .N), by = &quot;species&quot;] ni &lt;- DT[, .(ni = .N, Gi = sum(gi)), by = &quot;species&quot;] ni &lt;- ni[Ui, on = &quot;species&quot;] ni[, DAi := ni / A][, DRi := (DAi / sum(DAi)) * 100] ni[, DoAi := Gi / A][, DoRi := (DoAi / sum(DoAi)) * 100] ni[, FAi := (Ui / length(unique(DT$sample))) * 100][, FRi := (FAi / sum(FAi)) * 100] num_cols &lt;- names(ni)[sapply(ni, is.numeric)] ni[, (num_cols) := lapply(.SD, round, 4), .SDcols = num_cols] setnames(ni, old = &quot;species&quot;, new = &quot;Espécies&quot;) return(ni) } EH_result &lt;- EH(BD_$`Nome Científico`, BD_$Parc, BD_$DAP, A = 0.8) Resultados: 2.2.4.2 Índice de Shannon (Diversidade) Na aplicação, o cálculo do índice de Shannon avalia a diversidade alfa da comunidade vegetal. Um valor alto reflete maior diversidade e distribuição equitativa entre as espécies no local estudado. shannon &lt;- function(species_counts) { pi &lt;- species_counts / sum(species_counts) -sum(pi * log(pi), na.rm = TRUE) } H &lt;- shannon(EH_result$ni) cat(&quot;Índice de Shannon:&quot;, H, &quot;\\n&quot;) ## Índice de Shannon: 3.16804 2.2.4.3 Índice de Morisita (Agregação) Mede o padrão de distribuição espacial das espécies. Valores \\(I_\\delta &gt; 1\\) indicam agregação. morisita &lt;- function(species_counts, parcelas) { # Agregar os indivíduos por parcela counts &lt;- tapply(species_counts, parcelas, sum) N &lt;- sum(counts) # Total de indivíduos em todas as parcelas n &lt;- length(counts) # Número de parcelas numerator &lt;- n * sum(counts * (counts - 1)) # Soma dos xi(xi - 1) por parcela denominator &lt;- N * (N - 1) # Total de combinações possíveis I_M &lt;- numerator / denominator return(I_M) } # Exemplo de aplicação: # Substituir species_counts e parcelas pelos dados reais species_counts &lt;- BD_$DAP[!is.na(BD_$DAP)] # DAP como proxy de presença/indivíduo parcelas &lt;- BD_$Parc # Número da parcela correspondente I_delta &lt;- morisita(species_counts, parcelas) cat(&quot;Índice de Morisita corrigido:&quot;, I_delta, &quot;\\n&quot;) ## Índice de Morisita corrigido: 1.022617 2.2.4.4 Estrutura vertical e classificação em estratos A inclusão da dimensão vertical nos parâmetros fitossociológicos agrega uma visão tridimensional da comunidade florestal, indo além da análise convencional baseada apenas na densidade e dominância (horizontal). BD_$`H T` &lt;- as.numeric(BD_$`H T`) meanH &lt;- mean(BD_$`H T`, na.rm = TRUE) sdH &lt;- sd(BD_$`H T`, na.rm = TRUE) # Calcular estrato BD_$estrato &lt;- case_when( BD_$`H T` &lt; (meanH - sdH) ~ &quot;Inferior&quot;, BD_$`H T` &gt;= (meanH - sdH) &amp; BD_$`H T` &lt;= (meanH + sdH) ~ &quot;Médio&quot;, BD_$`H T` &gt; (meanH + sdH) ~ &quot;Superior&quot; ) # Calcular PSAi e PSRi resultados &lt;- BD_ %&gt;% group_by(estrato) %&gt;% mutate( Nj = n(), # Total de indivíduos no estrato N = nrow(BD_), # Total de indivíduos na floresta Pj = Nj / N # Peso do estrato no total ) %&gt;% group_by(`Nome Científico`, estrato) %&gt;% summarise( Nji = n(), # Número de indivíduos da espécie no estrato Nj = first(Nj), # Total de indivíduos no estrato Pj = first(Pj), # Peso do estrato PSAi_partial = (Nji / Nj) * Pj, # Contribuição parcial para PSAi .groups = &quot;drop&quot; ) %&gt;% group_by(`Nome Científico`) %&gt;% summarise( PSAi = sum(PSAi_partial, na.rm = TRUE) # Soma das contribuições parciais para PSAi ) %&gt;% ungroup() %&gt;% mutate( PSRi = (PSAi / sum(PSAi, na.rm = TRUE)) * 100 # PSRi como porcentagem global ) # Fusão das tabelas com left_join EH_result &lt;- EH_result %&gt;% left_join(resultados, by = c(&quot;Espécies&quot; = &quot;Nome Científico&quot;)) # Adicionando o Valor de Importância Ampliado (VIA) required_cols &lt;- c(&quot;DAi&quot;, &quot;DoAi&quot;, &quot;FAi&quot;, &quot;PSAi&quot;, &quot;DRi&quot;, &quot;DoRi&quot;, &quot;FRi&quot;, &quot;PSRi&quot;) missing_cols &lt;- required_cols[!required_cols %in% names(EH_result)] if (length(missing_cols) &gt; 0) { stop(paste(&quot;Colunas ausentes em `EH_result`: &quot;, paste(missing_cols, collapse = &quot;, &quot;))) } EH_result &lt;- EH_result %&gt;% mutate( VIAa = (DAi + DoAi + FAi + PSAi) / 4, # Cálculo do VIA absoluto ) # Visualizar os resultados finais com arredondamento resultado_final &lt;- EH_result %&gt;% arrange(desc(VIAa)) %&gt;% mutate(across(where(is.numeric), round, 4)) Na aplicação prática, a utilização do VIA, que combina parâmetros horizontais e verticais com indicadores de regeneração, fornece uma visão holística da importância das espécies. Isso é fundamental para identificar não apenas as espécies dominantes atuais, mas também aquelas com maior potencial de contribuir para a sustentabilidade futura do ecossistema. Referências Otávio Miranda Verly, et al. 2020. “Caracterização florística e fitossociologia de um fragmento de Cerradão em Cáceres, Mato Grosso”. Pesquisa Florestal Brasileira 40: e201801742. "],["odfhoasdhf.html", "3 odfhoasdhf ", " 3 odfhoasdhf "],["section.html", "3.1 123", " 3.1 123 pisaudhfukasdfuki 3.1.1 asdfasdfg print(2 + 2) ## [1] 4 print(2 + 3) ## [1] 5 print(2 + 4) ## [1] 6 3.1.2 asdfasdf print(2 + 2) ## [1] 4 print(2 + 3) ## [1] 5 print(2 + 4) ## [1] 6 "],["asdfasdfasdf.html", "3.2 asdfasdfasdf", " 3.2 asdfasdfasdf apsoiudfhoupiasjdfoikauiospdf asoidfjoashjdf sodfhasduasd spifjiasjdfoijsdfa 3.2.1 asefasdfgasdfasdf sfasdasdfasd print(2 + 2) ## [1] 4 print(2 + 3) ## [1] 5 print(2 + 4) ## [1] 6 3.2.2 Será denovo sfasdasdfasd print(2 + 2) ## [1] 4 print(2 + 3) ## [1] 5 print(2 + 4) ## [1] 6 "],["referências.html", "Referências", " Referências Otávio Miranda Verly, et al. 2020. “Caracterização florística e fitossociologia de um fragmento de Cerradão em Cáceres, Mato Grosso”. Pesquisa Florestal Brasileira 40: e201801742. Wickham, Hadley, e contributors. 2021. Tidyverse Style Guide. RStudio, PBC. https://style.tidyverse.org/. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
