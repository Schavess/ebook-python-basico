# Estruturas de Controle

---

As estruturas de controle s√£o fundamentais na programa√ß√£o, permitindo que o c√≥digo tome decis√µes e execute a√ß√µes repetitivas. Neste cap√≠tulo, vamos explorar condicionais, la√ßos de repeti√ß√£o, recursividade e muito mais.

---

## Desvio Condicional

Os desvios condicionais permitem que o programa execute diferentes blocos de c√≥digo dependendo de condi√ß√µes espec√≠ficas.

### Simples (if)

A estrutura mais b√°sica executa um bloco de c√≥digo apenas se a condi√ß√£o for verdadeira:

```{python}
nota = 6
if(nota < 6):
    print('Voc√™ ficou de PF!')
```

### Composto (if-else)

Permite executar um bloco se a condi√ß√£o for verdadeira e outro se for falsa:

```{python}
notas = [5.5, 6.7, 5.4, 7.0]

media_notas = sum(notas)/len(notas)

if(media_notas >= 6):
    print(f'Nota final: {media_notas}.  Parab√©ns, voc√™ est√° aprovado!')
else:
    print(f'Nota final: {media_notas}.Voc√™ ficou de PF!')
```

### M√∫ltiplas Condi√ß√µes (if-elif-else)

Quando h√° m√∫ltiplas condi√ß√µes a verificar:

```{python}
if(media_notas < 5):
    print(f'Nota: {media_notas}.Voc√™ precisa estudar muito!')
elif(media_notas >= 5 and media_notas < 6):
    print(f'Nota: {media_notas}.Cuidado! Estude mais!')
else:
    print(f'Nota: {media_notas}.Voc√™ est√° no caminho correto!')
```

### Exerc√≠cio: Conceitos

Crie um desvio condicional composto para definir o Conceito da m√©dia das notas do Gustavo. Estas foram as notas dele: 6.5, 4.6, 7.8, 5.4

| Conceitos | notas |
|-----------|-------|
| A         | 9-10  |
| B         | 7-9   |
| C         | 6-7   |
| D         | 5-6   |
| E         | 0-5   |

```{python}
notas_gustavo = [6.5, 4.6, 7.8, 5.4]
media_gustavo = sum(notas_gustavo) / len(notas_gustavo)

if media_gustavo >= 9:
    conceito = 'A'
elif media_gustavo >= 7:
    conceito = 'B'
elif media_gustavo >= 6:
    conceito = 'C'
elif media_gustavo >= 5:
    conceito = 'D'
else:
    conceito = 'E'

print(f'M√©dia: {media_gustavo:.2f}')
print(f'Conceito: {conceito}')
```

---

## La√ßos de Repeti√ß√£o

Os la√ßos de repeti√ß√£o permitem executar um bloco de c√≥digo m√∫ltiplas vezes.

### While

O la√ßo `while` executa um bloco de c√≥digo enquanto uma condi√ß√£o for verdadeira:

```{python}
i = 0
while (i < 10):
    print(i)
    i += 1
print(f'i={i}')
```

**Exemplo interativo:**

```{python, eval=FALSE}
from random import randint

# Menos um √© um valor que far√° do while False por padr√£o para pedir o n√∫mero do usu√°rio
numero_informado = -1
numero_secreto = randint(0, 10)

while (numero_informado != numero_secreto):
    numero_informado = int(input('Informe um n√∫mero entre 0 e 10: '))
print(f'N√∫mero secreto encontrado: {numero_secreto}')
```

### For

O la√ßo `for` itera sobre uma sequ√™ncia (lista, string, tupla, etc.).

#### range()

A fun√ß√£o `range()` gera uma sequ√™ncia de n√∫meros:

```{python}
# range(7) gera n√∫meros de 0 a 6
for i in range(7):
    print(i)
```

```{python}
# range(2, 7) gera n√∫meros de 2 a 6
for i in range(2, 7):
    print(i)
```

```{python}
# range(0, 8, 2) gera n√∫meros de 0 a 7, de 2 em 2
for i in range(0, 8, 2):
    print(i)
```

#### Iterando sobre strings e listas

```{python}
name = 'Arthur'
for i in name:
    print(i)
```

```{python}
names = ['Arthur', 'Fernanda', 'Marcos']
for i in names:
    print(i)
```

#### Iterando sobre dicion√°rios

```{python}
cadastro = {'nome': 'Jos√©',
            'idade': 45,
            'cel': '065999325454',
            'endere√ßo': 'Rua ABC'}
```

**Iterando sobre chaves:**

```{python}
for i in cadastro.keys():
    print(i)
```

**Iterando sobre valores:**

```{python}
for i in cadastro.values():
    print(i)
```

**Iterando sobre pares chave-valor:**

```{python}
for i, j in cadastro.items():
    print(i, '=', j)
```

### For com Else

O bloco `else` em um la√ßo `for` √© executado quando o la√ßo termina normalmente (n√£o foi interrompido por `break`):

```{python}
sequencia = range(1, 11)
sequencia_inversa = list(sequencia)[::-1]

for i in sequencia_inversa:
    print(i)
else:
    print('Decolou!üöÄ')
```

### Break e Continue

**Break:** Interrompe completamente o la√ßo:

```{python}
for x in range(1, 11):
    if x == 5:
        break
    print(x)

print('Acabou!')
```

**Continue:** Pula para a pr√≥xima itera√ß√£o do la√ßo:

```{python}
for x in range(1, 11):
    if x % 2 == 0:
        continue
    print(x)
```

---

## Match-Case (Switch)

A partir do Python 3.10, foi introduzido o `match-case`, que funciona como um `switch` em outras linguagens.

### Fake Switch (Antes do Python 3.10)

Antes do Python 3.10, era comum usar dicion√°rios para simular um switch:

```{python}
def dia_da_semana_switch(dia):
    dias = {
          1: "Domingo",
          2: "Segunda-Feira",
          3: "Ter√ßa-Feira",
          4: "Quarta-Feira",
          5: "Quinta-Feira",
          6: "Sexta-Feira",
          7: "S√°bado",
    }
    return dias.get(dia, "Dia Inv√°lido")

print(dia_da_semana_switch(2))
```

### Match-Case (Python 3.10+)

```{python}
def dia_da_semana(dia):
    match dia:
        case 1:
            return 'Domingo'
        case 2:
            return 'Segunda-Feira'
        case 3:
            return 'Ter√ßa-Feira'
        case 4:
            return 'Quarta-Feira'
        case 5:
            return 'Quinta-Feira'
        case 6:
            return 'Sexta-Feira'
        case 7:
            return 'S√°bado'
        case _:
            return 'Dia Inv√°lido'

print(dia_da_semana(1))
```

**Match com m√∫ltiplos valores:**

```{python}
def get_tipo_dia(dia):
    match dia:
        case 2 | 3 | 4 | 5 | 6:
            return 'Dia de semana'
        case 1 | 7:
            return 'Fim de semana'
        case _:
            return '** inv√°lido **'

print(get_tipo_dia(5))
```

---

## Packing e Unpacking

### Packing

Packing √© o processo de agrupar valores em uma estrutura de dados:

```{python}
lista = [1, 2, 3]
```

### Unpacking

Unpacking √© o processo de extrair valores de uma estrutura de dados:

```{python}
x, y, z = lista
print(x)
print(y)
print(z)
```

### Swap (Troca)

Unpacking permite trocar valores facilmente:

```{python}
x = 1
y = 2
print(x, y)

x, y = y, x  # Troca os valores
print(x, y)
```

**Aplica√ß√£o pr√°tica - Sequ√™ncia de Fibonacci:**

```{python}
def fibonacci(limite):
    penultimo = 0
    ultimo = 1
    print(f'{penultimo},{ultimo}', end=',' )
    while ultimo < limite:
        proximo = penultimo + ultimo
        print(proximo, end = ',')
        penultimo = ultimo
        ultimo = proximo

fibonacci(100)
```

**Usando swap para simplificar:**

```{python}
def fibonacci(limite):
    penultimo = 0
    ultimo = 1
    print(f'{penultimo},{ultimo}', end=',' )
    while ultimo < limite:
        penultimo, ultimo = ultimo, penultimo + ultimo  # Usando swap
        print(ultimo, end = ',')

fibonacci(100)
```

---

## Recursividade

Recursividade √© quando uma fun√ß√£o chama a si mesma. √â uma t√©cnica poderosa para resolver problemas que podem ser divididos em subproblemas similares.

### Fatorial

A fun√ß√£o fatorial de um n√∫mero inteiro n√£o negativo $n$, denotado por $n!$, √© definida como o produto de todos os inteiros positivos menores ou iguais a $n$. Formalmente:

$$
n! = n \times (n-1) \times (n-2) \times \cdots \times 2 \times 1
$$

Para $n = 0$, por defini√ß√£o:

$$
0! = 1
$$

**Implementa√ß√£o recursiva:**

```{python}
def fatorial(n):
    # Caso base: fatorial de 0 ou 1
    if n == 0 or n == 1:
        return 1
    # Passo recursivo: n! = n * (n-1)!
    else:
        return n * fatorial(n-1)

# Exemplo de uso
print(fatorial(4))
```

### Sequ√™ncia de Fibonacci

A sequ√™ncia de Fibonacci √© uma s√©rie de n√∫meros onde cada n√∫mero √© a soma dos dois anteriores, come√ßando com 0 e 1. A fun√ß√£o de Fibonacci $F(n)$ para um n√∫mero inteiro n√£o negativo $n$ √© definida recursivamente como:

$$
F(n) =
\begin{cases}
0 & \text{se } n = 0 \\
1 & \text{se } n = 1 \\
F(n-1) + F(n-2) & \text{se } n > 1
\end{cases}
$$

**Implementa√ß√£o recursiva:**

```{python}
def fibonacci(n):
    # Caso base: n = 0 ou n = 1
    if n == 0:
        return 0
    elif n == 1:
        return 1
    # Passo recursivo: soma dos dois anteriores
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Exemplo de uso
print(fibonacci(8))
```

**Vers√£o otimizada que retorna a sequ√™ncia:**

```{python}
def fibonacci_sequence(n, sequence=None):
    # Inicializa a lista na primeira chamada
    if sequence is None:
        sequence = [0, 1]

    # Verifica se a lista j√° tem todos os valores at√© a posi√ß√£o n
    if n >= len(sequence):
        # Calcula o pr√≥ximo n√∫mero e o adiciona √† lista
        next_value = fibonacci_sequence(n-1, sequence)[n-1] + fibonacci_sequence(n-2, sequence)[n-2]
        sequence.append(next_value)

    # Retorna a lista at√© a posi√ß√£o n
    return sequence[:n+1]

# Exemplo de uso
print(fibonacci_sequence(10))
```

---

## Lista de Exerc√≠cios

### Exerc√≠cio 1: C√°lculo de Volume Total de Madeira por Lote

Crie uma fun√ß√£o recursiva que estime o volume total de madeira (em metros c√∫bicos) que pode ser extra√≠do de um lote, dado o n√∫mero de toras. A fun√ß√£o deve receber o n√∫mero de toras por lote, o comprimento m√©dio das toras (em metros) e o di√¢metro m√©dio (em cent√≠metros) das toras.

```{python}
def calcular_volume_madeira(n_toras, comprimento_medio, diametro_medio, acumulado=0):
    if n_toras == 0:
        return acumulado
    else:
        volume_tora = (comprimento_medio * (diametro_medio/100) ** 2) * 3.141592 / 4
        return calcular_volume_madeira(n_toras-1, comprimento_medio, diametro_medio, acumulado + volume_tora)

# Exemplo de uso
n_toras = 5
comprimento_medio = 10  # metros
diametro_medio = 30  # cent√≠metros
volume_total = calcular_volume_madeira(n_toras, comprimento_medio, diametro_medio)
print(f'Volume total: {volume_total:.2f} m¬≥')
```

### Exerc√≠cio 2: Classifica√ß√£o de √Åreas de Reflorestamento por Classe de S√≠tio

Utilizando desvios condicionais, crie um sistema que classifique √°reas de reflorestamento baseado na altura dominante (Hdom) das √°rvores. A classifica√ß√£o em classes de s√≠tio deve ser feita de acordo com a Hdom informada pelo usu√°rio.

```{python}
def classificar_sitio(hdom):
    if hdom >= 30:
        return "Classe de S√≠tio I - Excelente"
    elif hdom >= 25:
        return "Classe de S√≠tio II - Bom"
    elif hdom >= 20:
        return "Classe de S√≠tio III - M√©dio"
    else:
        return "Classe de S√≠tio IV - Ruim"

# Exemplo de uso
hdom = 26  # Altura dominante em metros
print(classificar_sitio(hdom))
```

### Exerc√≠cio 3: Modelo de Crescimento Florestal

Desenvolva um script que modele o crescimento de uma floresta, dada uma taxa de crescimento constante. O script deve criar uma lista com o volume acumulado de madeira a cada ano.

```{python}
def modelo_crescimento(volume_inicial, taxa_crescimento, anos):
    volumes = [volume_inicial]
    for ano in range(1, anos + 1):
        volume_ano = volumes[-1] * (1 + taxa_crescimento)
        volumes.append(volume_ano)
    return volumes

# Exemplo de uso
volume_inicial = 100  # Volume inicial de madeira em metros c√∫bicos
taxa_crescimento = 0.05  # Taxa de crescimento anual (5%)
anos = 10  # N√∫mero de anos
volumes_acumulados = modelo_crescimento(volume_inicial, taxa_crescimento, anos)

print("Volume acumulado por ano:")
for ano, volume in enumerate(volumes_acumulados):
    print(f"Ano {ano}: {volume:.2f} m¬≥")
```

**Visualiza√ß√£o com matplotlib:**

```{python}
import matplotlib.pyplot as plt

# Dados do exemplo anterior
volume_inicial = 100
taxa_crescimento = 0.05
anos = 10

# Gerar a lista com os volumes acumulados
volumes_acumulados = modelo_crescimento(volume_inicial, taxa_crescimento, anos)

# Plotar o gr√°fico
plt.figure(figsize=(10, 6))
plt.plot(range(anos + 1), volumes_acumulados, marker='o', linestyle='-', color='green')
plt.title('Crescimento Acumulado do Volume de Madeira ao Longo dos Anos')
plt.xlabel('Ano')
plt.ylabel('Volume Acumulado de Madeira (m¬≥)')
plt.grid(True)
plt.show()
```

---

## Resumo

Neste cap√≠tulo, exploramos:

* **Desvios condicionais**: `if`, `if-else`, `if-elif-else`
* **La√ßos de repeti√ß√£o**: `while`, `for`
* **Controle de fluxo**: `break`, `continue`
* **Match-case**: Estrutura de sele√ß√£o m√∫ltipla (Python 3.10+)
* **Packing e Unpacking**: T√©cnicas para trabalhar com estruturas de dados
* **Recursividade**: Fun√ß√µes que chamam a si mesmas

Essas estruturas s√£o fundamentais para criar programas que tomam decis√µes e processam dados de forma eficiente. Pratique com os exerc√≠cios para consolidar seu conhecimento!
