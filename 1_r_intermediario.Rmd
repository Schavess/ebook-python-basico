# R Intermediário

---

Para aprofundar nossos conhecimentos sobre a linguagem vamos analisar:

1. Funções da família `apply()`;
2. O pacote `dplyr`;
3. O pacote `data.table`.
4. O pacote gráfico `lattice`

## Funções da família `apply()` no R

As funções da família `apply()` são usadas para realizar operações repetitivas em vetores, listas, matrizes e data frames de forma eficiente e vetorizada, substituindo muitos loops explícitos (`for`).

### **1. `apply()`**
Aplica uma função ao longo de uma **margem** de uma matriz ou array (linhas ou colunas).

- **Uso:** Para matrizes e arrays.  
- **Sintaxe:** `apply(X, MARGIN, FUN, ...)`
  - `X`: Matriz ou array.  
  - `MARGIN`: Margem a operar:
    - `1` para linhas.
    - `2` para colunas.  
  - `FUN`: Função a ser aplicada.

**Exemplo:**
```r
# Soma das colunas de uma matriz
mat <- matrix(1:9, nrow = 3)
apply(mat, 2, sum)
# Resultado: [1] 12 15 18

# Média das linhas
apply(mat, 1, mean)
# Resultado: [1] 2 5 8
```

### **2. `lapply()`**
Aplica uma função a cada elemento de uma **lista** ou **vetor** e retorna uma **lista** como resultado.

- **Uso:** Para listas e vetores.  
- **Sintaxe:** `lapply(X, FUN, ...)`

**Exemplo:**
```r
# Quadrado de cada elemento de um vetor
vec <- 1:5
lapply(vec, function(x) x^2)
# Resultado: [[1]] 1, [[2]] 4, [[3]] 9, [[4]] 16, [[5]] 25

# Aplicação em uma lista
lst <- list(a = 1:3, b = 4:6)
lapply(lst, sum)
# Resultado: $a 6, $b 15
```

### **3. `sapply()`**
Uma versão simplificada de `lapply()` que retorna um **vetor** ou **matriz** (se possível) em vez de uma lista.

- **Uso:** Para listas e vetores.  
- **Sintaxe:** `sapply(X, FUN, ...)`

**Exemplo:**
```r
# Quadrado de cada elemento
vec <- 1:5
sapply(vec, function(x) x^2)
# Resultado: [1] 1 4 9 16 25

# Soma dos elementos em uma lista
lst <- list(a = 1:3, b = 4:6)
sapply(lst, sum)
# Resultado: [1] 6 15
```

### **4. `vapply()`**
Semelhante a `sapply()`, mas requer que você **especifique o tipo de retorno esperado** (mais seguro).

- **Uso:** Para listas e vetores.  
- **Sintaxe:** `vapply(X, FUN, FUN.VALUE, ...)`
  - `FUN.VALUE`: Define o tipo e formato esperado do retorno.

**Exemplo:**
```r
# Soma dos elementos em uma lista com tipo esperado (numeric)
lst <- list(a = 1:3, b = 4:6)
vapply(lst, sum, numeric(1))
# Resultado: [1]  6 15
```

### **5. `mapply()`**
Aplica uma função a múltiplos argumentos/vetores **simultaneamente** (como um `map` em Python).

- **Uso:** Para múltiplos vetores ou listas.  
- **Sintaxe:** `mapply(FUN, ..., MoreArgs = NULL)`

**Exemplo:**
```r
# Soma de dois vetores
vec1 <- 1:5
vec2 <- 6:10
mapply(sum, vec1, vec2)
# Resultado: [1]  7  9 11 13 15

# Repetição customizada
mapply(rep, 1:3, 3:1)
# Resultado: [[1]] 1, [[2]] 2 2, [[3]] 3 3 3
```

### **6. `tapply()`**
Aplica uma função a subconjuntos de um vetor, definidos por um **fator** ou grupos.

- **Uso:** Para agrupamento.  
- **Sintaxe:** `tapply(X, INDEX, FUN, ...)`
  - `X`: Vetor numérico.
  - `INDEX`: Fator ou lista de fatores para agrupar.

**Exemplo:**
```r
# Média por grupo
vec <- c(1, 2, 3, 4, 5, 6)
grp <- factor(c("A", "A", "B", "B", "C", "C"))
tapply(vec, grp, mean)
# Resultado: $A 1.5, $B 3.5, $C 5.5
```

### **7. `by()`**
Semelhante a `tapply()`, mas retorna resultados organizados por **subgrupos** e funciona com data frames.

- **Uso:** Para data frames.  
- **Sintaxe:** `by(data, INDICES, FUN, ...)`

**Exemplo:**
```r
# Soma dos valores por grupo em um data frame
df <- data.frame(value = 1:6, group = c("A", "A", "B", "B", "C", "C"))
by(df$value, df$group, sum)
# Resultado:
# A: 3
# B: 7
# C: 11
```

### Conclusão {-}
As funções da família `apply()` tornam o R extremamente poderoso e eficiente para manipulação de dados. Use:
- **`apply()`** para matrizes/arrays.
- **`lapply()`** e **`sapply()`** para listas/vetores.
- **`mapply()`** para múltiplos vetores.
- **`tapply()`** e **`by()`** para agrupamentos.

---

## dplyr
O pacote dplyr é uma das ferramentas mais populares do ecossistema R para manipulação de dados. Ele fornece uma sintaxe simples e eficiente para tarefas como filtragem, ordenação, agrupamento e transformação de dados. Neste capítulo, exploraremos as principais funções do dplyr aplicadas a um conjunto de dados florestais.

### O que é o Pipe `%>%`?
O operador `%>%` é chamado de pipe.
Ele permite encadear funções de maneira a facilitar a leitura e compreensão do código.
Ao invés de ficar atribuindo valores intermediários ou aninhando várias funções, você simplesmente passa o resultado de uma função como entrada para a próxima.

#### Exemplos de Uso
Vamos usar o conjunto de dados mtcars para entender como o pipe facilita a manipulação de dados:

Sem `%>%` (Sem Pipe)
Imagine que queremos fazer as seguintes operações no dataset mtcars:

Filtrar apenas os carros que têm mais de 20 milhas por galão (mpg > 20).
Selecionar apenas as colunas mpg, cyl, e hp.
Sem o operador `%>%`, o código ficaria assim:

```{r}
library(dplyr)

# Sem pipe
filtered_data <- filter(mtcars, mpg > 20)
selected_data <- select(filtered_data, mpg, cyl, hp)
```
<br>
Com `%>%` (Com Pipe)
Podemos simplificar isso usando o pipe:

```{r}
library(dplyr)

# Usando pipe
selected_data <- mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)

head(selected_data) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
```
<br>
Note como o código com `%>%` é mais legível e direto. Ele segue uma lógica sequencial que permite facilmente entender o que está sendo feito em cada etapa.

---

### Tibbles
Tibbles são data frames com ajustes que os deixam mais amigáveis aos cientistas de dados. Elas são parte do pacote {tibble}. Assim, para começar a usá-las, instale e carregue o pacote.

```{r, eval=FALSE}
install.packages("tibble")
library(tibble)
```

Criando um exemplo:
```{r}
# Criando um exemplo de dados florestais
library(dplyr)

dados_florestais <- tibble::tibble(
  parcela = rep(1:5, each = 10),
  especie = sample(c("Cedro", "Ipê", "Jatobá", "Angelim", "Castanheira"), 50, replace = TRUE),
  dap_cm = round(runif(50, 10, 80), 1),  # Diâmetro em cm
  altura_m = round(runif(50, 5, 30), 1),  # Altura em metros
  volume_m3 = dap_cm * altura_m * 0.00007854 # Fórmula fictícia para volume
)

dados_florestais

```

---

### filter()

Podemos filtrar árvores de uma espécie específica ou com características particulares. Exemplo: selecionar árvores com DAP maior que 50 cm.

```{r}
# Filtrando árvores com DAP > 50 cm
arvores_grandes <- dados_florestais %>%
  filter(dap_cm > 50)

head(arvores_grandes)

```

### select()

Para trabalhar com um subconjunto de variáveis, podemos usar select(). Exemplo: selecionar apenas as colunas especie, dap_cm e altura_m.

```{r}
# Selecionando colunas específicas
dados_selecionados <- dados_florestais %>%
  select(especie, dap_cm, altura_m)

head(dados_selecionados)
```
### mutate()

Podemos criar novas variáveis com base em cálculos. Exemplo: calcular o índice de esbeltez (altura/DAP).
```{r}
# Adicionando o índice de esbeltez
dados_florestais <- dados_florestais %>%
  mutate(indice_esbeltez = altura_m / dap_cm)

head(dados_florestais)
```
### arrange()

Para ordenar as árvores pelo DAP em ordem decrescente:
```{r}
# Ordenando por DAP
dados_ordenados <- dados_florestais %>%
  arrange(desc(dap_cm))

head(dados_ordenados)
```
### summarise() e group_by()

Agrupar e resumir dados é uma tarefa comum em análises florestais. Exemplo: calcular o DAP médio e o volume total por espécie.
```{r}
# Resumo por espécie
resumo_especies <- dados_florestais %>%
  group_by(especie) %>%
  summarise(
    dap_medio = mean(dap_cm),
    volume_total = sum(volume_m3)
  )

resumo_especies
```

### ungroup()
Após usar group_by() em uma análise, o objeto resultante permanece "agrupado". Isso pode afetar operações subsequentes. Para remover o agrupamento, usamos ungroup().

Exemplo: calcular o DAP médio por espécie e, em seguida, adicionar uma coluna ao dataset original com o DAP médio total (sem agrupamento).
```{r}
# Resumo por espécie com agrupamento
resumo_especies <- dados_florestais %>%
  group_by(especie) %>%
  summarise(dap_medio = mean(dap_cm))

# Adicionando o DAP médio geral
dap_geral <- resumo_especies %>%
  ungroup() %>%
  summarise(dap_medio_geral = mean(dap_medio))

dap_geral

```

## data.table

### O que é o `:=`?
O operador `:=` é chamado de operador de atribuição por referência.
Ele pertence ao pacote data.table e é usado para adicionar ou modificar colunas em um data.table.
O `:=` é mais eficiente do que usar `<-` em um data.table, pois faz as modificações "por referência", o que significa que não cria cópias desnecessárias dos dados, sendo muito mais rápido e eficiente em termos de memória.

### Exemplos de Uso
Vamos usar o pacote data.table para entender como o `:=`
 funciona.

Primeiro, vamos criar um data.table com alguns dados fictícios:
```{r}
library(data.table)

# Criação de um data.table
DT <- data.table(
  id = 1:5,
  valor = c(10, 15, 20, 25, 30)
)

```
Adicionando uma Nova Coluna com `:=`

Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor:
```{r}
DT[, valor_2 := valor * 2]

print(DT)

```
<br>

Modificando uma Coluna Existente com `:=`

Podemos também modificar uma coluna existente. Vamos modificar a coluna valor_2 para ser o triplo do valor da coluna valor:
```{r}
DT[, valor_2 := valor * 3]

print(DT)
```

## Pacote `lattice`

O pacote lattice é uma poderosa ferramenta para criar gráficos condicionais e exploratórios. Ele é especialmente útil quando trabalhamos com conjuntos de dados categorizados, como medidas florestais agrupadas por espécies, localizações ou períodos de tempo.

### Dispersão condicional

Imagine que temos dados sobre o diâmetro das árvores (DAP) e a altura delas em diferentes parcelas florestais. Com lattice, podemos visualizar as relações entre essas variáveis, separadas por parcelas.

```{r}
library(lattice)

# Dados simulados
set.seed(123)
dados <- data.frame(
  Parcela = factor(rep(1:3, each = 50)),
  DAP = c(rnorm(50, mean = 20, sd = 5), 
          rnorm(50, mean = 25, sd = 6), 
          rnorm(50, mean = 22, sd = 4)),
  Altura = c(rnorm(50, mean = 15, sd = 3), 
             rnorm(50, mean = 18, sd = 2), 
             rnorm(50, mean = 16, sd = 3))
)

# Gráfico de dispersão por parcela
xyplot(Altura ~ DAP | Parcela, data = dados,
       main = "Altura x DAP por Parcela",
       xlab = "Diâmetro à Altura do Peito (DAP)",
       ylab = "Altura (m)",
       col = "red", pch = 16)

```

### Histograma condicional

Os histogramas condicionais são úteis para visualizar a distribuição do DAP em diferentes espécies de árvores.

```{r}
# Dados simulados
dados$Especie <- factor(rep(c("Espécie A", "Espécie B", "Espécie C"), each = 50))

# Histograma por espécie
histogram(~ DAP | Especie, data = dados,
          main = "Distribuição do DAP por Espécie",
          xlab = "Diâmetro à Altura do Peito (DAP)",
          col = "lightblue", border = "black")

```

### Boxplot comparativo

Os boxplots são ideais para comparar a altura das árvores entre espécies em diferentes parcelas.

```{r}
# Ajustando o boxplot
bwplot(Altura ~ Especie | Parcela, data = dados,
       main = "Altura por Espécie e Parcela",
       xlab = "Espécie", ylab = "Altura (m)",
       col = "forestgreen",
       par.settings = list(box.rectangle = list(col = "blue"),
                           plot.symbol = list(col = "darkgreen", pch = 16)),
       scales = list(x = list(rot = 45))) # Rotação dos rótulos no eixo X


```

### Barras por classes

Se quisermos visualizar a contagem de árvores por espécie em cada parcela, o gráfico de barras é uma escolha apropriada.

```{r}
# Reorganizando os dados para melhor visualização
library(reshape2)
dados_barras <- as.data.frame(contagem)
names(dados_barras) <- c("Especie", "Parcela", "Contagem")

# Gráfico de barras mais visual
barchart(Contagem ~ Especie | Parcela, data = dados_barras,
         main = "Número de Árvores por Espécie e Parcela",
         xlab = "Espécie", ylab = "Número de Árvores",
         col = c("darkgreen", "lightgreen", "brown"),
         auto.key = list(columns = 3), # Legenda com as espécies
         panel = function(x, y, ...) {
           panel.barchart(x, y, ...)
           panel.text(x, y, labels = y, pos = 3, cex = 0.8) # Rótulos numéricos
         },
         scales = list(x = list(rot = 45))) # Rotação dos rótulos no eixo X

```

### Gráficos 3D

Se você trabalha com dados ambientais ou florestais que envolvem superfícies, como elevação, densidade de árvores ou biomassa em um terreno, os gráficos de superfície podem ser úteis.

```{r}
library(lattice)

# Dados simulados
set.seed(123)
dados <- data.frame(
  Parcela = factor(rep(1:3, each = 50)),  # Três parcelas
  DAP = c(rnorm(50, mean = 20, sd = 5), 
          rnorm(50, mean = 25, sd = 4), 
          rnorm(50, mean = 30, sd = 6)),  # Diâmetro
  Altura = c(rnorm(50, mean = 15, sd = 3), 
             rnorm(50, mean = 18, sd = 2), 
             rnorm(50, mean = 20, sd = 4)), # Altura
  Biomassa = c(rnorm(50, mean = 200, sd = 50), 
               rnorm(50, mean = 300, sd = 40), 
               rnorm(50, mean = 400, sd = 60)) # Biomassa
)

# Gráfico 3D condicional
cloud(Biomassa ~ DAP * Altura | Parcela, data = dados,
      main = "Relação 3D: Biomassa, DAP e Altura por Parcela",
      xlab = "Diâmetro (DAP)",
      ylab = "Altura (m)",
      zlab = "Biomassa (kg)",
      screen = list(z = 60, x = -60),  # Ajuste do ângulo de visualização
      col = "forestgreen", 
      pch = 16)  # Pontos no gráfico

```

```{r}
library(lattice)

# Gerando coordenadas x e y (grid regular)
x <- seq(-10, 10, length = 30)  # 30 pontos no eixo X
y <- seq(-10, 10, length = 30)  # 30 pontos no eixo Y

# Gerando altura (z) com base em uma função para criar uma superfície
z <- outer(x, y, function(x, y) x * 2)

# Convertendo para um data frame para usar com cloud()
dados <- expand.grid(x = x, y = y)
dados$z <- as.vector(z)

# Gráfico 3D simulando o terreno
cloud(z ~ x * y, data = dados,
      main = "Terreno Simulado em 3D",
      xlab = "Coordenada X",
      ylab = "Coordenada Y",
      zlab = "Altura (Z)",
      screen = list(z = 60, x = -60),  # Ângulo de visualização
      col = "lightblue",              # Cor dos pontos
      panel.3d.cloud = panel.3dscatter, # Adiciona pontos ao gráfico
      pch = 16)                       # Pontos sólidos

```

### Densidade Condicional

Se você deseja comparar distribuições contínuas, como a altura de árvores em diferentes regiões ou espécies, os gráficos de densidade são uma alternativa elegante aos histogramas.

```{r}
# Gerando dados simulados com a variável Especie
set.seed(123)
dados <- data.frame(
  Altura = c(rnorm(50, mean = 15, sd = 3), 
             rnorm(50, mean = 18, sd = 2), 
             rnorm(50, mean = 20, sd = 4)),
  Especie = factor(rep(c("Espécie A", "Espécie B", "Espécie C"), each = 50))
)


# Gráfico de densidade
densityplot(~ Altura | Especie, data = dados,
            main = "Densidade da Altura por Espécie",
            xlab = "Altura (m)",
            plot.points = FALSE, # Ocultar pontos individuais
            col = c("blue", "darkgreen", "orange"))

```

### Matrix de dispersão (Scatterplot Matrix)

Se você tem várias variáveis numéricas e quer explorar as relações entre elas, o lattice oferece o splom() (scatterplot matrix).

```{r}
# Gerando os dados simulados com DAP e Altura
set.seed(123)
dados <- data.frame(
  DAP = c(rnorm(50, mean = 20, sd = 5), 
          rnorm(50, mean = 25, sd = 6), 
          rnorm(50, mean = 30, sd = 4)),
  Altura = c(rnorm(50, mean = 15, sd = 3), 
             rnorm(50, mean = 18, sd = 2), 
             rnorm(50, mean = 20, sd = 4))
)

# Calculando a biomassa
dados$Biomassa <- dados$DAP * dados$Altura * rnorm(150, mean = 0.1, sd = 0.01)

# Gerando o scatterplot matrix (splom)
library(lattice)
splom(~ dados[c("DAP", "Altura", "Biomassa")],
      main = "Matriz de Dispersão",
      col = "darkblue", pch = 16)


```

### Temporal condicional

Se você possui dados temporais, como crescimento de árvores ao longo de anos ou medições sazonais, os gráficos de linha com painéis são muito úteis.

```{r}
# Dados simulados de crescimento anual
set.seed(123)
anos <- 2000:2020
crescimento <- expand.grid(Ano = anos, Especie = c("Espécie A", "Espécie B", "Espécie C"))
crescimento$Altura <- with(crescimento, ifelse(Especie == "Espécie A", 
                                               rnorm(length(Ano), mean = Ano - 1995, sd = 0.5),
                                               ifelse(Especie == "Espécie B", 
                                                      rnorm(length(Ano), mean = Ano - 1993, sd = 0.7),
                                                      rnorm(length(Ano), mean = Ano - 1990, sd = 0.6))))

# Gráfico de linha com painéis
xyplot(Altura ~ Ano | Especie, data = crescimento,
       type = "o", col = "darkgreen", pch = 16,
       main = "Crescimento por Espécie ao Longo dos Anos",
       xlab = "Ano", ylab = "Altura (m)")

```