# R Intermediário

## Funções da família `apply()` no R

As funções da família `apply()` são usadas para realizar operações repetitivas em vetores, listas, matrizes e data frames de forma eficiente e vetorizada, substituindo muitos loops explícitos (`for`).

### **1. `apply()`**
Aplica uma função ao longo de uma **margem** de uma matriz ou array (linhas ou colunas).

- **Uso:** Para matrizes e arrays.  
- **Sintaxe:** `apply(X, MARGIN, FUN, ...)`
  - `X`: Matriz ou array.  
  - `MARGIN`: Margem a operar:
    - `1` para linhas.
    - `2` para colunas.  
  - `FUN`: Função a ser aplicada.

**Exemplo:**
```r
# Soma das colunas de uma matriz
mat <- matrix(1:9, nrow = 3)
apply(mat, 2, sum)
# Resultado: [1] 12 15 18

# Média das linhas
apply(mat, 1, mean)
# Resultado: [1] 2 5 8
```

### **2. `lapply()`**
Aplica uma função a cada elemento de uma **lista** ou **vetor** e retorna uma **lista** como resultado.

- **Uso:** Para listas e vetores.  
- **Sintaxe:** `lapply(X, FUN, ...)`

**Exemplo:**
```r
# Quadrado de cada elemento de um vetor
vec <- 1:5
lapply(vec, function(x) x^2)
# Resultado: [[1]] 1, [[2]] 4, [[3]] 9, [[4]] 16, [[5]] 25

# Aplicação em uma lista
lst <- list(a = 1:3, b = 4:6)
lapply(lst, sum)
# Resultado: $a 6, $b 15
```

### **3. `sapply()`**
Uma versão simplificada de `lapply()` que retorna um **vetor** ou **matriz** (se possível) em vez de uma lista.

- **Uso:** Para listas e vetores.  
- **Sintaxe:** `sapply(X, FUN, ...)`

**Exemplo:**
```r
# Quadrado de cada elemento
vec <- 1:5
sapply(vec, function(x) x^2)
# Resultado: [1] 1 4 9 16 25

# Soma dos elementos em uma lista
lst <- list(a = 1:3, b = 4:6)
sapply(lst, sum)
# Resultado: [1] 6 15
```

### **4. `vapply()`**
Semelhante a `sapply()`, mas requer que você **especifique o tipo de retorno esperado** (mais seguro).

- **Uso:** Para listas e vetores.  
- **Sintaxe:** `vapply(X, FUN, FUN.VALUE, ...)`
  - `FUN.VALUE`: Define o tipo e formato esperado do retorno.

**Exemplo:**
```r
# Soma dos elementos em uma lista com tipo esperado (numeric)
lst <- list(a = 1:3, b = 4:6)
vapply(lst, sum, numeric(1))
# Resultado: [1]  6 15
```

### **5. `mapply()`**
Aplica uma função a múltiplos argumentos/vetores **simultaneamente** (como um `map` em Python).

- **Uso:** Para múltiplos vetores ou listas.  
- **Sintaxe:** `mapply(FUN, ..., MoreArgs = NULL)`

**Exemplo:**
```r
# Soma de dois vetores
vec1 <- 1:5
vec2 <- 6:10
mapply(sum, vec1, vec2)
# Resultado: [1]  7  9 11 13 15

# Repetição customizada
mapply(rep, 1:3, 3:1)
# Resultado: [[1]] 1, [[2]] 2 2, [[3]] 3 3 3
```

### **6. `tapply()`**
Aplica uma função a subconjuntos de um vetor, definidos por um **fator** ou grupos.

- **Uso:** Para agrupamento.  
- **Sintaxe:** `tapply(X, INDEX, FUN, ...)`
  - `X`: Vetor numérico.
  - `INDEX`: Fator ou lista de fatores para agrupar.

**Exemplo:**
```r
# Média por grupo
vec <- c(1, 2, 3, 4, 5, 6)
grp <- factor(c("A", "A", "B", "B", "C", "C"))
tapply(vec, grp, mean)
# Resultado: $A 1.5, $B 3.5, $C 5.5
```

### **7. `by()`**
Semelhante a `tapply()`, mas retorna resultados organizados por **subgrupos** e funciona com data frames.

- **Uso:** Para data frames.  
- **Sintaxe:** `by(data, INDICES, FUN, ...)`

**Exemplo:**
```r
# Soma dos valores por grupo em um data frame
df <- data.frame(value = 1:6, group = c("A", "A", "B", "B", "C", "C"))
by(df$value, df$group, sum)
# Resultado:
# A: 3
# B: 7
# C: 11
```

### Conclusão {-}
As funções da família `apply()` tornam o R extremamente poderoso e eficiente para manipulação de dados. Use:
- **`apply()`** para matrizes/arrays.
- **`lapply()`** e **`sapply()`** para listas/vetores.
- **`mapply()`** para múltiplos vetores.
- **`tapply()`** e **`by()`** para agrupamentos.

---

## dplyr

### O que é o Pipe `%>%`?
O operador `%>%` é chamado de pipe.
Ele permite encadear funções de maneira a facilitar a leitura e compreensão do código.
Ao invés de ficar atribuindo valores intermediários ou aninhando várias funções, você simplesmente passa o resultado de uma função como entrada para a próxima.

#### Exemplos de Uso
Vamos usar o conjunto de dados mtcars para entender como o pipe facilita a manipulação de dados:

Sem `%>%` (Sem Pipe)
Imagine que queremos fazer as seguintes operações no dataset mtcars:

Filtrar apenas os carros que têm mais de 20 milhas por galão (mpg > 20).
Selecionar apenas as colunas mpg, cyl, e hp.
Sem o operador `%>%`, o código ficaria assim:

```{r}
library(dplyr)

# Sem pipe
filtered_data <- filter(mtcars, mpg > 20)
selected_data <- select(filtered_data, mpg, cyl, hp)
```
<br>
Com `%>%` (Com Pipe)
Podemos simplificar isso usando o pipe:

```{r}
library(dplyr)

# Usando pipe
selected_data <- mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)

head(selected_data) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
```
<br>
Note como o código com `%>%` é mais legível e direto. Ele segue uma lógica sequencial que permite facilmente entender o que está sendo feito em cada etapa.

---

### Tibbles
Tibbles são data frames com ajustes que os deixam mais amigáveis aos cientistas de dados. Elas são parte do pacote {tibble}. Assim, para começar a usá-las, instale e carregue o pacote.

```{r, eval=FALSE}
install.packages("tibble")
library(tibble)
```

Criando um exemplo:
```{r}
# Criando um exemplo de dados florestais
library(dplyr)

dados_florestais <- tibble::tibble(
  parcela = rep(1:5, each = 10),
  especie = sample(c("Cedro", "Ipê", "Jatobá", "Angelim", "Castanheira"), 50, replace = TRUE),
  dap_cm = round(runif(50, 10, 80), 1),  # Diâmetro em cm
  altura_m = round(runif(50, 5, 30), 1),  # Altura em metros
  volume_m3 = dap_cm * altura_m * 0.00007854 # Fórmula fictícia para volume
)

dados_florestais

```

---

### filter()

Podemos filtrar árvores de uma espécie específica ou com características particulares. Exemplo: selecionar árvores com DAP maior que 50 cm.

```{r}
# Filtrando árvores com DAP > 50 cm
arvores_grandes <- dados_florestais %>%
  filter(dap_cm > 50)

head(arvores_grandes)

```

### select()

Para trabalhar com um subconjunto de variáveis, podemos usar select(). Exemplo: selecionar apenas as colunas especie, dap_cm e altura_m.

```{r}
# Selecionando colunas específicas
dados_selecionados <- dados_florestais %>%
  select(especie, dap_cm, altura_m)

head(dados_selecionados)
```
### mutate()

Podemos criar novas variáveis com base em cálculos. Exemplo: calcular o índice de esbeltez (altura/DAP).
```{r}
# Adicionando o índice de esbeltez
dados_florestais <- dados_florestais %>%
  mutate(indice_esbeltez = altura_m / dap_cm)

head(dados_florestais)
```
### arrange()

Para ordenar as árvores pelo DAP em ordem decrescente:
```{r}
# Ordenando por DAP
dados_ordenados <- dados_florestais %>%
  arrange(desc(dap_cm))

head(dados_ordenados)
```
### summarise() e group_by()

Agrupar e resumir dados é uma tarefa comum em análises florestais. Exemplo: calcular o DAP médio e o volume total por espécie.
```{r}
# Resumo por espécie
resumo_especies <- dados_florestais %>%
  group_by(especie) %>%
  summarise(
    dap_medio = mean(dap_cm),
    volume_total = sum(volume_m3)
  )

resumo_especies
```

### ungroup()
Após usar group_by() em uma análise, o objeto resultante permanece "agrupado". Isso pode afetar operações subsequentes. Para remover o agrupamento, usamos ungroup().

Exemplo: calcular o DAP médio por espécie e, em seguida, adicionar uma coluna ao dataset original com o DAP médio total (sem agrupamento).
```{r}
# Resumo por espécie com agrupamento
resumo_especies <- dados_florestais %>%
  group_by(especie) %>%
  summarise(dap_medio = mean(dap_cm))

# Adicionando o DAP médio geral
dap_geral <- resumo_especies %>%
  ungroup() %>%
  summarise(dap_medio_geral = mean(dap_medio))

dap_geral

```

## data.table

### O que é o `:=`?
O operador `:=` é chamado de operador de atribuição por referência.
Ele pertence ao pacote data.table e é usado para adicionar ou modificar colunas em um data.table.
O `:=` é mais eficiente do que usar `<-` em um data.table, pois faz as modificações "por referência", o que significa que não cria cópias desnecessárias dos dados, sendo muito mais rápido e eficiente em termos de memória.

### Exemplos de Uso
Vamos usar o pacote data.table para entender como o `:=`
 funciona.

Primeiro, vamos criar um data.table com alguns dados fictícios:
```{r}
library(data.table)

# Criação de um data.table
DT <- data.table(
  id = 1:5,
  valor = c(10, 15, 20, 25, 30)
)

```
Adicionando uma Nova Coluna com `:=`

Podemos adicionar uma nova coluna chamada valor_2 que seja o dobro do valor existente na coluna valor:
```{r}
DT[, valor_2 := valor * 2]

print(DT)

```
<br>

Modificando uma Coluna Existente com `:=`

Podemos também modificar uma coluna existente. Vamos modificar a coluna valor_2 para ser o triplo do valor da coluna valor:
```{r}
DT[, valor_2 := valor * 3]

print(DT)
```

## Manipulando dados com dplyr

O pacote dplyr é uma das ferramentas mais populares do ecossistema R para manipulação de dados. Ele fornece uma sintaxe simples e eficiente para tarefas como filtragem, ordenação, agrupamento e transformação de dados. Neste capítulo, exploraremos as principais funções do dplyr aplicadas a um conjunto de dados florestais.

